---
title: "Data analysis for WP10"
author: "Patrizia Maier"
date: "`r format(Sys.time(), '%d %B, %Y')`"
output: html_document
---

```{r setup, include=F, cache=F}

library(tidyverse)
library(janitor)
library(gtsummary)
library(performance)
library(rstatix)
library(ggpubr)
library(WRS2)
# library(WRS) # alternative: # source("Rallfun-v40.txt") # for WRS
library(afex)
library(lme4)
library(nlme)
library(lmeresampler)
# library(parameters)
# library(lavaSearch2)
library(emmeans)
library(car)
library(DHARMa)
# install.packages('tinytex')
# tinytex::install_tinytex() # latex for pdf file creation

# set contrast coding
options(contrasts=c(unordered="contr.sum", ordered="contr.poly"))
# options("contrasts")
# options(contrasts=c(unordered="contr.treatment", ordered="contr.poly"))

```


```{r load_data, include=F}
file_name <- "../WP10_data/WP10_results/wp10_navigation_data.RData"
load(file_name)
sm_orig <- sm_data 
rm(file_name)

file_name <- "../WP10_data/WP10_results/wp10_post_nav_data.RData"
load(file_name)
rm(file_name)
```


### Demographics 

##### Available navigation data 

```{r demo_1, echo=F, message=F, warning=F}
t1 <- sm_data %>% 
  filter(trial==1, session==1) %>% 
  select(group, sex) %>%
  tbl_summary(by=group,
              label=list(sex ~ "Gender"),
              statistic=list(all_categorical() ~ "{n}")) %>% 
  modify_header(label="Starmaze data",
                stat_by="**{level}** N = {n}") %>% 
  modify_footnote(everything() ~ NA)
t1
rm(t1)

# t1 %>%
#   as_flex_table() %>%
#   flextable::save_as_docx(path="TEST.docx")
```
 
##### Available post-navigation data 
 
```{r demo_2, echo=F, message=F, warning=F}
t2 <- pt_data %>% 
  filter(trial==4) %>% 
  select(group, sex) %>%
  tbl_summary(by=group,
              label=list(sex ~ "Gender"),
              statistic=list(all_categorical() ~ "{n}")) %>% 
  modify_header(label="Post-navigation data",
                stat_by="**{level}** N = {n}") %>% 
  modify_footnote(everything() ~ NA)
t2
rm(t2)
```


```{r stats_data}

## practise motor control
data_p <- sm_data %>%
  filter(condition %in% c("practise")) %>%  
  select(id, group, sex, time, path_length, velocity) %>% 
  droplevels()

## learning
data_l <- sm_data %>%
  filter(exclude_trial_matlab==0) %>% 
  filter(condition %in% c("main_learn")) %>% 
  mutate(trial_in_cond_f=factor(trial_in_cond),
         trial_in_cond_0=trial_in_cond-1,
         trial_in_cond_c=trial_in_cond-4.5,
         block_f=factor(block)) %>% 
  droplevels()

# # box-cox transformation
# bc_t <- MASS::boxcox(time ~ group*block_f*trial_in_cond_c, data=data_l)
# lambda_t <- bc_t$x[which.max(bc_t$y)]
# bc_p <- MASS::boxcox(path_distance ~ group*block_f*trial_in_cond_c, data=data_l)
# lambda_p <- bc_p$x[which.max(bc_p$y)]
# data_l <- data_l %>% 
#   mutate(boxcox_time=((time^lambda_t-1)/lambda_t),
#          boxcox_path=((path_distance^lambda_p-1)/lambda_p))
# rm(bc_t, bc_p, lambda_t, lambda_p)

## probe 
data <- sm_data %>% 
  filter(condition %in% c("allo_ret", "ego_ret")) %>% 
  select(id, group, sex, session, block, trial, condition, trial_in_cond, goal, 
         correct_final_alley, final_distance, final_local_distance,
         time, path_length_error, 
         path_distance, dtw_path_distance, chosen_path_distance,
         path_edit_distance, chosen_path_edit_distance,
         target_distance_error, chosen_target_distance, 
         rotation_degrees, rotation_turns, rotation_turns_by_path_length,
         exclude_trial_matlab) %>% 
  mutate(across(correct_final_alley:rotation_turns_by_path_length, 
                ~ case_when(exclude_trial_matlab==1 ~ NaN, T ~ .))) %>% 
  droplevels()

## probe correct trials 
data_c <- data %>% 
  filter(correct_final_alley==1) %>% 
  droplevels()

```


### Navigation
#### Motor control trial 

```{r stats_motor_control}

# ::: METHOD: single value per person, therefore (robust) ANOVA ::: #

# time: GROUPS DIFFER SIGNIFICANTLY 
t1way(time ~ group, data=data_p, tr=0.2, alpha=0.05, nboot=1000)
lincon(time ~ group, data=data_p, tr=0.2, alpha=0.05,  nboot=1000, method="bonferroni") # default: hochberg

# path length: GROUPS DIFFER SIGNIFICANTLY
t1way(path_length ~ group, data=data_p, tr=0.2, alpha=0.05, nboot=1000)
lincon(path_length ~ group, data=data_p, tr=0.2, alpha=0.05,  nboot=1000, method="bonferroni")

# velocity: no differences 
t1way(velocity ~ group, data=data_p, tr=0.2, alpha=0.05, nboot=1000)
lincon(velocity ~ group, data=data_p, tr=0.2, alpha=0.05,  nboot=1000, method="bonferroni")

# ::: MEANING: during practise, the younger the participants, the longer they take to complete the trial and the more they deviate from an ideal path (i.e. difficulties with joystick motor control) --> include time, path length and/or velocity as covariate ::: #

```

#### Learning trials 

```{r stats_learning}

# ::: METHOD: per person 8 trials ? 3 blocks (= 24 trials) with continuous outcome, therefore lmm model ::: #
# watch out for convergence (stepwise reduction of random effects), normality of residuals, homoscedasticity and outliers # 

## -- time -- ##
# 1) standard lmer model 
# contrasts set to sum-coding by mixed
learn.time <- mixed(time ~ group*block_f*trial_in_cond_c + (block_f|id), 
                    data=data_l, expand_re=T,
                    control=lmerControl(optimizer="bobyqa", optCtrl=list(maxfun=1e6)))
# check model
simulationOutput <- simulateResiduals(fittedModel=learn.time$full_model, plot=F)
testResiduals(simulationOutput)
plotResiduals(simulationOutput)
testCategorical(simulationOutput, catPred=data_l$group)
# model diagnostics are bad


# 2) advanced lme model with variance estimation 
# contrasts set in beginning, check options("contrasts") if in doubt 
learn.time_base <- lme(time ~ group*block_f*trial_in_cond_c,
                         random=~1+block_f| id,
                         data=data_l, method="ML")
learn.time_var <- update(learn.time_base, weights=varIdent(form=~1 | group))
anova.lme(learn.time_base, learn.time_var) # type="marginal" ?

plot(learn.time_var, resid(., type="p") ~ fitted(.) | group)
plot(learn.time_var, group ~ resid(., type="p"))
plot(learn.time_var, block_f ~ resid(., type="p"))

## 3) advanced lme model with variance estimation and transformed outcome
# contrasts set in beginning, check options("contrasts") if in doubt
learn.time_var_t <- lme(1/time ~ group*block_f*trial_in_cond_c,
                         random=~1+block_f | id,
                         weights=varIdent(form=~1 | group),
                         data=data_l, method="ML")

plot(learn.time_var_t, resid(., type="p") ~ fitted(.) | group, abline=0)
plot(learn.time_var_t, group ~ resid(., type="p"))

# main effects & interactions  
anova.lme(learn.time_var_t, type="marginal", adjustSigma=T)

# post-hoc comparisons 
emtrends(learn.time_var_t, pairwise ~ block_f, var="trial_in_cond_c", adjust="bonferroni")
emtrends(learn.time_var_t, pairwise ~ group, var="trial_in_cond_c", adjust="bonferroni")
emmeans(learn.time_var_t, pairwise ~ group, type="response", adjust="bonferroni")


## work in progress: check other variances 
## 4) advanced lme model withother types of variance estimation
learn.time_var2 <- update(learn.time_base, weights=varPower(form=~time)) # does not converge
learn.time_var3 <- update(learn.time_base, weights=varConstPower(form=~time)) # does not converge
learn.time_var4 <- update(learn.time_base, weights=varExp(form=~time))
learn.time_var5 <- update(learn.time_base, weights=varPower(form=~time | group))
learn.time_var6 <- update(learn.time_base, weights=varConstPower(form=~time | group)) # does not converge
learn.time_var7 <- update(learn.time_base, weights=varComb(varIdent(form=~1 | group), varExp(form=~time)))

anova(learn.time_base, learn.time_var, learn.time_var4, learn.time_var5, learn.time_var7)

plot(learn.time_var5, resid(., type="p") ~ fitted(.) | group, abline=0)
plot(learn.time_var5, group ~ resid(., type="p"))
plot(learn.time_var5, block_f ~ resid(., type="p"))
hist(resid(learn.time_var5, type="p"))

anova(learn.time_base, learn.time_var, learn.time_var5)

anova(learn.time_base, type="marginal")
anova(learn.time_var, type="marginal")
anova(learn.time_var_t, type="marginal")
anova(learn.time_var5, type="marginal")

## 

# # extract estimated variance
# variance <- learn.time_var_log$modelStruct$varStruct %>%
#   coef(unconstrained = FALSE, allCoef = TRUE) %>%
#   enframe(name = "grp", value = "varStruct") %>%
#   mutate(sigma         = learn.time_var_log$sigma) %>%
#   mutate(StandardError = sigma * varStruct) %>%
#   mutate(Variance      = StandardError ^ 2)


## -- path metric distance -- ##

## 1) standard lme model without variance estimation 
# contrasts set in beginning, check options("contrasts") if in doubt 
learn.path <- lme(path_distance ~ group*block_f*trial_in_cond_c,
                  random=~1+block_f | id, 
                  data=data_l, method="REML")
plot(learn.path, resid(., type="p") ~ fitted(.) | group)
plot(learn.path, group ~ resid(., type="p"))


## 2) advanced lme model wit variance estimation 
# contrasts set in beginning, check options("contrasts") if in doubt 
learn.path_var <- lme(path_distance ~ group*block_f*trial_in_cond_c,
                  random=~1+block_f | id, 
                  weights=varIdent(form=~1 | group),
                  data=data_l, method="REML")
plot(learn.path_var, resid(., type="p") ~ fitted(.) | group)
plot(learn.path_var, group ~ resid(., type="p"))

anova(learn.path, learn.path_var) # variance estimation improves model 


## 3) lme model wit variance estimation and transformed outcome
# contrasts set in beginning, check options("contrasts") if in doubt 
learn.path_var_t <- lme(1/path_distance ~ group*block_f*trial_in_cond_c,
                  random=~1+block_f | id, 
                  weights=varIdent(form=~1 | group),
                  data=data_l, method="REML")
plot(learn.path_var_t, resid(., type="p") ~ fitted(.) | group)
plot(learn.path_var_t, group ~ resid(., type="p"))


## -- path edit distance -- ##
## 1) standard lme model without variance estimation 
# contrasts set in beginning, check options("contrasts") if in doubt 
learn.path_ed <- lme(zone_editdistance ~ group*block_f*trial_in_cond_c,
                  random=~1+block_f | id, 
                  data=data_l, method="REML")
plot(learn.path_ed, resid(., type="p") ~ fitted(.) | group)
plot(learn.path_ed, group ~ resid(., type="p"))


## 2) advanced lme model wit variance estimation
# contrasts set in beginning, check options("contrasts") if in doubt 
learn.path_ed_var <- lme(zone_editdistance ~ group*block_f*trial_in_cond_c,
                  random=~1+block_f | id, 
                  weights=varIdent(form=~1 | group),
                  data=data_l, method="REML")
plot(learn.path_ed_var, resid(., type="p") ~ fitted(.) | group)
plot(learn.path_ed_var, group ~ resid(., type="p"))

anova(learn.path_ed, learn.path_ed_var) # variance estimation improves model 


## -- target metric distance -- ##

## -- (initial) rotation  -- ##


```

#### Probe trials 

```{r stats_probe_global_accuracy}

# ::: METHOD: per person several trials (session, condition) with binomial outcome, therefore glmm model ::: #
# watch out for convergence (stepwise reduction of random effects) # 

# -- correct final alley -- ##
# 1) full binomial model (with reduced random effects due to failed convergence)
probe.acc <- mixed(correct_final_alley ~ group*session*condition + 
                     (session*condition||id), data=data, na.action=na.omit, expand_re=T,
                   family=binomial(link="logit"), method="LRT",
                   control=glmerControl(optimizer="bobyqa", optCtrl=list(maxfun=1e6)))

# check model
simulationOutput <- simulateResiduals(fittedModel=probe.acc$full_model, plot=F)
testResiduals(simulationOutput) 
plotResiduals(simulationOutput) 
testCategorical(simulationOutput, catPred=data$group[data$exclude_trial_matlab==0])
testCategorical(simulationOutput, catPred=data$session[data$exclude_trial_matlab==0])
testCategorical(simulationOutput, catPred=data$condition[data$exclude_trial_matlab==0])
# diagnostics: ok 

# post-test for fixed effects
# TBD: add effect size calculation
afex_plot(probe.acc, "session", "group", "condition", id = "id",
          data_geom = ggbeeswarm::geom_quasirandom)

probe.acc
emmeans(probe.acc, pairwise ~ group, type="response", adjust="bonferroni")
emmeans(probe.acc, pairwise ~ session, type="response")
emmeans(probe.acc, pairwise ~ condition, type="response")

# ::: MEANING: Significant differences between age groups (the older, the better), sessions (s1 better than s2) and slight difference between conditions (ego slightly better than allo), no interactions. ::: # 

```

```{r stats_probe_global_accuracy_change}

# ::: METHOD: one aggregated value per person, therefore (robust) ANOVA ::: #  

# --- change calculation --- #
data_prepost <- data %>% 
  select(id, group, session, trial, condition, correct_final_alley) %>%
  pivot_wider(id_cols=c(id, trial, group, condition),
              names_from=session,
              names_prefix="s_",
              values_from=correct_final_alley) %>%
  group_by(id, group, condition) %>%
  summarise_at(vars(s_1, s_2), mean, na.rm=T) %>% 
  mutate(change_diff=s_2-s_1,
         change_rel=s_2/s_1,
         change_reldiff=(s_2-s_1)/s_1) %>% 
  ungroup() %>% 
  droplevels()


# --- change relative difference --- # 
# 1) standard ANOVA
# contrasts are set to sum by default
aov.change <- aov_car(change_reldiff ~ group*condition + Error(id/condition), data=data_prepost)
qqPlot(data_prepost$change_reldiff) # non-normality
data_prepost %>% shapiro_test(change_reldiff) 
plot(predict(aov.change), residuals(aov.change), main="Residuals vs. Predicted") # homoscedasticity ok
data_prepost %>% levene_test(change_reldiff ~ group) 
summary(aov.change)
emmeans(aov.change, pairwise ~ group | condition, adjust="bonferroni")


# 2) robust ANOVA from WRS/WRS2 
# contrasts are set to sum by default (I think)
# # robust mixed anova 
raov.change <- bwtrim(change_reldiff ~ group*condition, id=id, data=data_prepost, tr=0.2)
# # alternative to trim: mom-esitmator
# sppba(change_reldiff ~ group*condition, id=id, data=data_prepost, est="mom", avg=TRUE, nboot=500, MDIS=FALSE)
# sppbb(change_reldiff ~ group*condition, id=id, data=data_prepost, est="mom", avg=TRUE, nboot=500)
# sppbi(change_reldiff ~ group*condition, id=id, data=data_prepost, est="mom", avg=TRUE, nboot=500)
raov.change
# using one-way post-test lincon() because no dedicated post-test for bwtrim() 
lincon(change_reldiff ~ group, data=data_prepost, tr=0.2, alpha=0.05, method="bonferroni")


# ::: MEANING: Some evidence in favor of consolidation differences between children and adults. However, effect was found only in robust and not in standard ANOVA. There was also no significant group*session interaction in the previous analysis. Does this make sense? ::: #

```

```{r stats_probe_local_accuracy}

### A) final distance in correct trials 
ggplot(data_c, aes(x=group, y=final_distance)) +
  geom_boxplot() + 
  facet_grid(session ~ condition)

### B) final distance in relation to local environment (alley boundary) for all trials 
ggplot(data, aes(x=group, y=final_local_distance)) +
  geom_boxplot() + 
  facet_grid(session ~ condition)


### for comparison: final distance in all trials 
ggplot(data, aes(x=group, y=final_distance)) +
  geom_boxplot() + 
  facet_grid(session ~ condition)

```

```{r stats_probe_metric}

## -- time -- ##
probe.time <- lme(time ~ group*session*condition,
                         random=~session+condition | id,
                         data=data, na.action=na.omit, method="ML")
probe.time_var <- update(probe.time, random=list(id=pdDiag(~ condition + session)),
                         weights=varIdent(form=~1 | group))
anova.lme(probe.time, probe.time_var) 

plot(probe.time_var, resid(., type="p") ~ fitted(.) | group)
plot(probe.time_var, group ~ resid(., type="p"))


probe.time_t <- lme(log(time) ~ group*session*condition,
                    random=~session+condition | id,
                    data=data, na.action=na.omit, method="ML")
probe.time_var_t <-  update(probe.time_t, random=list(id=pdDiag(~ condition + session)),
                         weights=varIdent(form=~1 | group))
anova(probe.time_t, probe.time_var_t)

plot(probe.time_var_t, resid(., type="p") ~ fitted(.) | group)
plot(probe.time_var_t, group ~ resid(., type="p"))

qqnorm(resid(probe.time))
qqline(resid(probe.time))

# # test bootstrapping
# set.seed(1234)
# m <- lmeresampler::bootstrap(probe.time_var, .f=fixef, type="reb", B=100, reb_type=1)


# not super stable 
anova(probe.time0)
anova.lme(probe.time, type="marginal") 
anova.lme(probe.time_t, type="marginal")  
anova.lme(probe.time_var, type="marginal")  
anova.lme(probe.time_var_t, type="marginal") 

emmeans(probe.time, pairwise ~ group | session | condition, adjust="bonferroni")
emmeans(probe.time_t, pairwise ~ group | session | condition, adjust="bonferroni")
emmeans(probe.time_var, pairwise ~ group | session | condition, adjust="bonferroni")
emmeans(probe.time_var_t, pairwise ~ group | session | condition, adjust="bonferroni")



## -- path metric distance  -- ##

probe.path <- lme(chosen_path_distance ~ group*session*condition,
                  random=list(id=pdDiag(~ condition + session)),
                  data=data, method="ML")
probe.path_var <- update(probe.path,
                         weights=varIdent(form=~1 | group))
anova.lme(probe.path, probe.path_var) 

plot(probe.time_var, resid(., type="p") ~ fitted(.) | group)
plot(probe.time_var, group ~ resid(., type="p"))


# probe.path_t <- lme(1/chosen_path_distance*100 ~ group*session*condition,
#                     random=list(id=pdDiag(~ condition + session)),
#                     data=data, method="ML")
# probe.path_var_t <-  update(probe.path_t, 
#                          weights=varIdent(form=~1 | group))
# anova(probe.path_t, probe.path_var_t)
# 
# plot(probe.path_var_t, resid(., type="p") ~ fitted(.) | group)
# plot(probe.path_var_t, group ~ resid(., type="p"))


# relatively stable 
anova.lme(probe.path, type="marginal") 
# anova.lme(probe.path_t, type="marginal")  
anova.lme(probe.path_var, type="marginal")  
# anova.lme(probe.path_var_t, type="marginal") 


emmeans(probe.path, pairwise ~ group | session | condition, adjust="bonferroni")
# emmeans(probe.path_t, pairwise ~ group | session | condition, adjust="bonferroni")
emmeans(probe.path_var, pairwise ~ group | session | condition, adjust="bonferroni")
# emmeans(probe.path_var_t, pairwise ~ group | session | condition, adjust="bonferroni")


## -- path edit distance  -- ##

## -- target metric distance -- ##

## -- rotation  -- ##
ggplot(data, aes(x=group, y=rotation_degrees)) +
  geom_boxplot() + 
  facet_grid(session ~ condition)

ggplot(data, aes(x=group, y=rotation_turns)) +
  geom_boxplot() + 
  facet_grid(session ~ condition)

ggplot(data, aes(x=group, y=rotation_turns_by_path_length)) +
  geom_boxplot() + 
  facet_grid(session ~ condition)


probe.rot <- lme(rotation_turns_by_path_length ~ group*session*condition,
                         random=list(id=pdDiag(~ condition + session)), 
                         data=data, method="ML")
probe.rot_var <- update(probe.rot, weights=varIdent(form=~1 | group))

anova.lme(probe.rot, probe.rot_var)
plot(probe.rot_var, resid(., type="p") ~ fitted(.) | group)
plot(probe.rot_var, group ~ resid(., type="p"))

anova.lme(probe.rot_var, type="marginal") 

emmeans(probe.rot_var, pairwise ~ group | condition, adjust="bonferroni")


# probe.rot <- mixed(rotation_turns_by_path_length ~ group*session*condition + 
#                      (condition||id), data=data, expand_re=T,
#                    control=lmerControl(optimizer="bobyqa", optCtrl=list(maxfun=1e6)))
# 
# # check model
# simulationOutput <- simulateResiduals(fittedModel=probe.rot$full_model, plot=F)
# testResiduals(simulationOutput) 
# plotResiduals(simulationOutput) 
# testCategorical(simulationOutput, catPred=data$group)
# testCategorical(simulationOutput, catPred=data$session)
# testCategorical(simulationOutput, catPred=data$condition)
# # diagnostics: not great 
# 
# afex_plot(probe.rot, "condition", "group", "session", id = "id",
#           data_geom = ggbeeswarm::geom_quasirandom)


### change values or rather not? 


```

```{r stats_probe_strategy}

table(data$search_strategy, data$group)

da <- data %>% filter(condition=="allo_ret")
table(da$search_strategy, da$group)
de <- data %>% filter(condition=="ego_ret")
table(de$search_strategy, de$group)


# option 1) fisher test: tests independence of rows and columns in a contingency table with fixed marginals.
fisher.test(table(data$search_strategy, data$group), simulate.p.value=T)

# option 2) discANOVA from WRS2: tests hypothesis that independent groups have identical multinomial distributions. 
discANOVA(search_strategy ~ group, data=data, nboot=500) 
discmcp(search_strategy ~ group, data=data, alpha=0.05, nboot=500)

discANOVA(search_strategy ~ group, data=data %>% filter(condition=="allo_ret"), nboot=500) 
discmcp(search_strategy ~ group, data=data %>% filter(condition=="allo_ret"), alpha=0.05, nboot=500)

discANOVA(search_strategy ~ group, data=data %>% filter(condition=="ego_ret"), nboot=500) 
discmcp(search_strategy ~ group, data=data %>% filter(condition=="ego_ret"), alpha=0.05, nboot=500)

```

```{r stats_probe_allo_strategy}

# TBD: change preprocessing in Matlab to make more inclusive 
data_allo_strategy <- data %>% 
  filter(condition=="allo_ret", session==1) %>% 
  drop_na(search_strategy_in_allo) %>% 
  mutate(search_strategy_2=fct_recode(search_strategy_in_allo, allo="direct_allo", 
                                      allo="detour_allo", ego="direct_ego", ego="detour_ego"))

table(data_allo_strategy$search_strategy_2, data_allo_strategy$group)

# option 1) fisher test: tests independence of rows and columns in a contingency table with fixed marginals.
fisher.test(table(data_allo_strategy$search_strategy_2, data_allo_strategy$group), simulate.p.value=T)

# option 2) discANOVA from WRS2: tests hypothesis that independent groups have identical multinomial distributions. 
discANOVA(search_strategy_2 ~ group, data=data_allo_strategy, nboot=500) 
discmcp(search_strategy_2 ~ group, data=data_allo_strategy, alpha=0.05, nboot=500)

# option 3) multinomial linear regression 


# ::: MEANING: xxx ::: #

```

```{r stats_probe_ego_strategy}

### EXPLORATIV 

data_ego <- data %>% 
  filter(condition=="ego_ret") %>% 
  select(id, group, session, trial, block, condition, goal_i, correct_final_alley) %>% 
  mutate(goal_f=factor(goal_i))

probe_ego.acc <- mixed(correct_final_alley ~ group*session*goal_f +  
                         (session*goal_f||id), data=data_ego, expand_re=T,
                   family=binomial(link="logit"), method="LRT",
                   control=glmerControl(optimizer="bobyqa", optCtrl=list(maxfun=1e6)))

afex_plot(probe_ego.acc, "session", "group", "goal_f", id = "id",
          data_geom = ggbeeswarm::geom_quasirandom)

emmeans(probe_ego.acc, pairwise ~ group | session | goal_f, type="response", adjust="bonferroni")
emmeans(probe_ego.acc, pairwise ~ goal_f, type="response", adjust="bonferroni")
emmeans(probe_ego.acc, pairwise ~ group, type="response", adjust="bonferroni")
emmeans(probe_ego.acc, pairwise ~ session, type="response", adjust="bonferroni")


# data_allo <- data %>% 
#   filter(condition=="allo_ret") %>% 
#   select(id, group, session, trial, block, condition, goal_i, correct_final_alley) %>% 
#   mutate(goal_f=factor(goal_i))
# 
# probe_allo.acc <- mixed(correct_final_alley ~ group*session*goal_f +  
#                          (session+goal_f||id), data=data_allo, expand_re=T,
#                    family=binomial(link="logit"), method="LRT",
#                    control=glmerControl(optimizer="bobyqa", optCtrl=list(maxfun=1e6)))
# 
# afex_plot(probe_allo.acc, "session", "group", "goal_f", id = "id",
#           data_geom = ggbeeswarm::geom_quasirandom)
# 
# emmeans(probe_allo.acc, pairwise ~ group | session | goal_f, type="response", adjust="bonferroni")
# emmeans(probe_allo.acc, pairwise ~ goal_f, type="response", adjust="bonferroni")
# emmeans(probe_allo.acc, pairwise ~ group, type="response", adjust="bonferroni")
# emmeans(probe_allo.acc, pairwise ~ session, type="response", adjust="bonferroni")

t1 <- data_l %>% 
  select(id, group, session, trial, goal_i, correct_final_alley, time, path_distance) %>% 
  mutate(goal_f=factor(goal_i)) %>% 
  group_by(id, group, session, goal_f) %>% 
  summarize(correct_final_alley=mean(correct_final_alley, na.rm=T),
            time=mean(time, na.rm=T),
            path=mean(path_distance, na.rm=T))

ggplot(t1, aes(x=goal_f, y=time)) +
  geom_boxplot() +
  facet_wrap(~ group)

ggplot(t1, aes(x=goal_f, y=path)) +
  geom_boxplot() +
  facet_wrap(~ group)


t2 <- data %>% 
  select(id, group, session, condition, trial, goal_i, correct_final_alley, final_distance, time, path_distance) %>% 
  mutate(goal_f=factor(goal_i)) %>% 
  filter(session==1) %>% 
  group_by(id, group, condition, goal_f) %>% 
  summarize(correct_final_alley=mean(correct_final_alley, na.rm=T),
            final_distance=mean(final_distance, na.rm=T),
            time=mean(time, na.rm=T),
            path=mean(path_distance, na.rm=T))

ggplot(t2, aes(x=goal_f, y=final_distance)) +
  geom_boxplot() +
  facet_grid(condition ~ group)

ggplot(t2, aes(x=goal_f, y=time)) +
  geom_boxplot() +
  facet_grid(condition ~ group)

ggplot(t2, aes(x=goal_f, y=path)) +
  geom_boxplot() +
  facet_grid(condition ~ group)

ggplot(t2, aes(x=goal_f, y=final_distance)) +
  geom_boxplot() +
  facet_wrap(~ condition)

ggplot(t2, aes(x=goal_f, y=time)) +
  geom_boxplot() +
  facet_wrap(~ condition)

ggplot(t2, aes(x=goal_f, y=path)) +
  geom_boxplot() +
  facet_wrap(~ condition)

```


### Post-navigation memory test
#### Identifying the maze layout 

```{r stats_layout}

data <- pt_data %>% 
  filter(condition=="layout") %>% 
  drop_na(score)

# option 1) fisher test: tests independence of rows and columns in a contingency table with fixed marginals.
fisher.test(table(data$score, data$group))
pairwise_fisher_test(table(data$score, data$group), p.adjust.method="bonferroni")

# option 2) discANOVA from WRS2: tests hypothesis that independent groups have identical multinomial distributions. 
discANOVA(score ~ group, data=data, nboot=500)
discmcp(score ~ group, data=data, alpha=0.05, nboot=500) 

# ::: MEANING: significant differences between age groups in performance ::: #

```

#### Identifying the landmarks 

```{r stats_landmark}
data <- pt_data %>% 
  filter(condition=="landmarks") %>% 
  drop_na(score)

# option 1) standard ANOVA
aov.lm <- aov_car(score ~ group + Error(id), data=data)
qqPlot(data$score) # non-normality
data %>% shapiro_test(score) 
plot(predict(aov.lm), residuals(aov.lm), main="Residuals vs. Predicted") # homoscedasticity ok
data %>% levene_test(score ~ group) 
summary(aov.lm)
emmeans(aov.lm, pairwise ~ group, adjust="bonferroni")

# option 2) robust ANOVA (WSR2)
t1way(score ~ group, data=data, tr=0.2, nboot=1000)
lincon(score ~ group, data=data, tr=0.2, nboot=1000, method="bonferroni")

# ::: MEANING: no reliable, significant differences between age groups in performance ::: #

```

#### Identifying the relationships between landmarks and goals 

```{r stats_gmda}

data <- pt_data %>% 
  filter(condition=="position") %>% 
  drop_na(score)

# option 1) standard ANOVA
aov.gmda <- aov_car(score ~ group + Error(id), data=data)
qqPlot(data$score) # non-normality
data %>% shapiro_test(score) 
plot(predict(aov.gmda), residuals(aov.gmda), main="Residuals vs. Predicted") # heteroscedasticity
data %>% levene_test(score ~ group) 
summary(aov.gmda)
emmeans(aov.gmda, pairwise ~ group, adjust="bonferroni")

# option 2) robust ANOVA (WSR2)
t1way(score ~ group, data=data, tr=0.2, nboot=1000)
lincon(score ~ group, data=data, tr=0.2, nboot=1000, method="bonferroni")

# ::: MEANING: significant differences between children and adults in performance ::: #

```

```{r stats_gmda_explore}

# file_name <- "../WP10_data/WP10_results/wp10_GMDA_data_220505.Rdata"
# load(file_name)
# rm(file_name)

# # individual scores
# CanOrg <- data_gmda %>% filter(gmda_measure=="SQRT(CanOrg)")
# CanAcc <- data_gmda %>% filter(gmda_measure=="CanAcc")
# DistAcc <- data_gmda %>% filter(gmda_measure=="DistAcc")
# AngleAcc <- data_gmda %>% filter(gmda_measure=="AngleAcc")

# boxplot <- function(d){
#   ggplot(data=d, aes(x=group, y=score, fill=group)) +
#     geom_boxplot(outlier.shape=NA) +
#     geom_point()
# }

# boxplot(CanOrg)
# lincon(score ~ group, data=CanOrg, tr=0.2, nboot=1000, method="bonferroni")

# boxplot(CanAcc)
# lincon(score ~ group, data=CanAcc, tr=0.2, nboot=1000, method="bonferroni")

# boxplot(DistAcc)
# lincon(score ~ group, data=DistAcc, tr=0.2, nboot=1000, method="bonferroni")

# boxplot(AngleAcc)
# lincon(score ~ group, data=AngleAcc, tr=0.2, nboot=1000, method="bonferroni")

# # composite score
# GMDA <- data_gmda %>% filter(gmda_measure %in% c("SQRT(CanOrg)", "CanAcc", "DistAcc", "AngleAcc")) %>%
#   group_by(id, group) %>% summarise(score=mean(score))

# boxplot(GMDA)
# lincon(score ~ group, data=GMDA, tr=0.2, nboot=1000, method="bonferroni")

# rm(data_gmda, GMDA, CanOrg, CanAcc, DistAcc, AngleAcc, boxplot)

rm(list=ls(pattern="x"))
   
```