---
title: "Data analysis for WP10"
author: "Patrizia Maier"
date: "`r format(Sys.time(), '%d %B, %Y')`"
output: html_document
---

```{r setup, include=F, cache=F}

library(tidyverse)
library(janitor)
library(gtsummary)
library(performance)
library(afex)
library(WRS2)
library(lme4)
library(emmeans)
library(car)
library(MASS)
library(rstatix)
library(ggpubr)
# library(multcomp)
# library(nlme)
# library(Rcpp)
# library(robustlmm)
# install.packages('tinytex')
# tinytex::install_tinytex() # latex for pdf file creation

```


```{r load_data, include=F}
file_name <- "../WP10_data/WP10_results/wp10_navigation_data.RData"
load(file_name)
sm_orig <- sm_data 
rm(file_name)

file_name <- "../WP10_data/WP10_results/wp10_post_nav_data.RData"
load(file_name)
rm(file_name)
```


## Demographics 

Available navigation data 

```{r demo_1, echo=F, message=F, warning=F}
t1 <- sm_data %>% 
  filter(trial_num==1, session==1) %>% 
  select(group, sex) %>%
  tbl_summary(by=group,
              label=list(sex ~ "Gender"),
              statistic=list(all_categorical() ~ "{n}")) %>% 
  modify_header(label="Starmaze data",
                stat_by="**{level}** N = {n}") %>% 
  modify_footnote(everything() ~ NA)
t1
rm(t1)

# t1 %>%
#   as_flex_table() %>%
#   flextable::save_as_docx(path="TEST.docx")
```
 
Available post-navigation data 
 
```{r demo_2, echo=F, message=F, warning=F}
t2 <- pt_data %>% 
  filter(trial_num==1) %>% 
  select(group, sex) %>%
  tbl_summary(by=group,
              label=list(sex ~ "Gender"),
              statistic=list(all_categorical() ~ "{n}")) %>% 
  modify_header(label="Post-navigation data",
                stat_by="**{level}** N = {n}") %>% 
  modify_footnote(everything() ~ NA)
t2
rm(t2)
```

```{r stats_correct1}
data <- sm_data %>%
  filter(exclude_trial_matlab==0) %>% 
  filter(condition %in% c("allo_ret", "ego_ret"))

data_c <- data %>% 
  filter(correct_final_alley==1) %>% 
  mutate(log_fd=log(final_distance))

```

```{r stats_correct2}

# test full modell with glmer()
# glmer.full <- glmer(correct_final_alley ~ group*session*condition + 
#                       (session*condition|id), data=data, 
#                     family=binomial(link="logit"))
# all_fit(glmer.full) # optimizer bobyqa ok 


# alternative approach: mixed() from afex() with LRT
# full model with random intercept, slope and correlations
# mixed.full_opt_lrt_1 <- mixed(correct_final_alley ~ group*session*condition +
#                                 (session*condition|id), data=data, family=binomial,
#                               method="LRT", 
#                               control=glmerControl(optimizer="bobyqa", 
#                                                    optCtrl=list(maxfun=1e6)))
# does not fully converge

# full model with random intercept and slope, no correlations
# mixed.full_opt_lrt_2 <- mixed(correct_final_alley ~ group*session*condition +
#                               (session*condition||id), data=data, family=binomial,
#                             method="LRT", expand_re=T,
#                             control=glmerControl(optimizer="bobyqa",
#                                                  optCtrl=list(maxfun=1e6)))
# does converge

# compare models 
# mixed.full_opt_lrt_1$anova_table
# mixed.full_opt_lrt_2$anova_table
# anova(mixed.full_opt_lrt_2, mixed.full_opt_lrt_1)

# plots for random effects
# lattice::dotplot(ranef(mixed.full_opt_lrt_2$full_model, condV=TRUE))

# post-test with fixed effects
# emmeans(mixed.full_opt_lrt_2, pairwise ~ group, type="response", adjust="bonferroni")
# emmeans(mixed.full_opt_lrt_2, pairwise ~ session, type="response")

```

```{r stats_finaldistance}

ggplot(data_c, aes(x=final_distance)) +
  geom_histogram() +
  facet_wrap(~group)

ggplot(data_c, aes(x=log_fd)) +
  geom_histogram() +
  facet_wrap(~group)

# # find distribution
# qqp(data_c$final_distance, "norm") # normal 
# qqp(data_c$final_distance, "lnorm")
# gamma <- fitdistr(data_c$final_distance, "gamma")
# qqp(data_c$final_distance, "gamma", shape=gamma$estimate[[1]], rate=gamma$estimate[[2]])


## basic model
# 1a) full model  
lmer.full <- mixed(final_distance ~ group*session*condition + 
                     (session*condition|id), data=data_c,
                   control=lmerControl(optimizer="bobyqa",
                                       optCtrl=list(maxfun=1e6)))
summary(lmer.full)$varcor
# model does not converge

# 1b) reduced model 
lmer.red <- mixed(final_distance ~ group*session*condition + 
                        (session|id), data=data_c,
                      control=lmerControl(optimizer="bobyqa", 
                                          optCtrl=list(maxfun=1e6)))
summary(lmer.red)$varcor
check_model(lmer.red$full_model, panel=F)
# model does converge but diagnostics are bad 


## log-transformed outcome 
# 2a) full model  
lmer.full_log <- mixed(log_fd ~ group*session*condition + 
                         (session*condition|id), data=data_c, 
                       control=lmerControl(optimizer="bobyqa",
                                           optCtrl=list(maxfun=1e6)))
summary(lmer.full_log)$varcor
# model does not converge

# 2b) reduced model
lmer.red_log <- mixed(log_fd ~ group*session*condition + 
                        (session|id), data=data_c,
                      control=lmerControl(optimizer="bobyqa", 
                                          optCtrl=list(maxfun=1e6)))
summary(lmer.red_log)$varcor
check_model(lmer.red_log$full_model, panel=F)
# model does converge and diagnostics good (top homoskedasticity, ok normality residuals)


## gaussian with log/inverse link
# 3a) full model  
glmer.full_link <- mixed(final_distance ~ group*session*condition + 
                          (session*condition|id), data=data_c, 
                        family=gaussian(link="log"), method="LRT",
                        control=glmerControl(optimizer="bobyqa",
                                             optCtrl=list(maxfun=1e6)))
summary(glmer.full_link)$varcor
# model does not converge

# 3b) reduced model
glmer.red_link <- mixed(final_distance ~ group*session*condition + 
                          (session|id), data=data_c,
                        family=gaussian(link="log"), method="LRT",
                        control=glmerControl(optimizer="bobyqa", 
                                             optCtrl=list(maxfun=1e6)))
summary(glmer.red_link)$varcor
check_model(glmer.red_link$full_model, panel=F)
# 


## gamma distribution with inverse link (default)
# 4a) full model
glmer.full_gamma <- mixed(final_distance ~ group*session*condition + 
                            (session*condition|id), data=data_c,
                          family=Gamma(link="inverse"), method="LRT",
                          control=glmerControl(optimizer="bobyqa", 
                                               optCtrl=list(maxfun=1e6)))
summary(glmer.full_gamma)$varcor
# model does not converge 

# 4b) reduced model
glmer.red_gamma <- mixed(final_distance ~ group*session*condition + 
                           (session|id), data=data_c,
                         family=Gamma(link="inverse"), method="LRT",
                         control=glmerControl(optCtrl=list(maxfun=1e6),
                                              optimizer="bobyqa"))
summary(glmer.red_gamma)$varcor
check_model(glmer.red_gamma$full_model, panel=F)
# model does converge and diagnostics ok (bad heteroskedasticity, good normality residuals)


## inverse gaussian distribution: does not converge & also no reduced model 

## what about gamma with identity link? error message


# lmer.red_log$anova_table
# emmeans(lmer.red_log, pairwise ~ group, adjust="bonferroni")
# emmeans(lmer.red_log, pairwise ~ session)
# afex_plot(lmer.red_log,  "session", "group", id = "id",
#           data_geom = ggbeeswarm::geom_quasirandom)

# glmer.red_gamma$anova_table
# emmeans(glmer.red_gamma, pairwise ~ group, adjust="bonferroni")
# emmeans(glmer.red_gamma, pairwise ~ session)
# emm1 <- emmeans(glmer.red_gamma, "group", by="session")
# pairs(emm1, by = NULL, adjust = "holm")
# afex_plot(glmer.red_gamma,  "session", "group", id = "id",
#           data_geom = ggbeeswarm::geom_quasirandom)

# coef <- coef(lmer.red_log$full_model)$id %>% select(`(Intercept)`,session1)


```

```{r stats_path}

ggplot(data, aes(x=path_distance)) +
  geom_histogram() +
  facet_wrap(~group)

```



```{r stats_layout}

data <- pt_data %>% 
  filter(condition=="layout")

fisher.test(table(data$score, data$group))
pairwise_fisher_test(table(data$score, data$group), p.adjust.method="bonferroni")

```

```{r stats_gmda}

data <- pt_data %>% 
  filter(condition=="position")

# ### histogramm
# ggplot(data, aes(x=score)) +
#   geom_histogram(binwidth=0.1) + 
#   facet_wrap(~group)
#   
# ### normality
# data %>% group_by(group, session) %>% shapiro_test(score)
# ggqqplot(data, "score", ggtheme = theme_bw()) + facet_grid(~group)
# 
# ### homoscedasticity
# data %>% levene_test(score ~ group)

### ANOVA
summary(aov(score ~ group, data=data))
pairwise.t.test(data$score, data$group, p.adjust.method="bonferroni")
performance::r2(aov(score ~ group, data=data))

### robust ANOVA (WSR2)
t1waybt(score ~ group, data=data, tr=0.2, nboot=2000)
mcppb20(score ~ group, data=data, tr=0.2, nboot=2000)

### Kruskal-Wallis test 
kruskal.test(score ~ group, data=data)
dunn_test(score ~ group, data=data, p.adjust.method="bonferroni")

```

```{r stats_landmark}
data <- pt_data %>% 
  filter(condition=="landmarks")

# ### histogramm
# ggplot(data, aes(x=score)) +
#   geom_histogram(binwidth=0.1) +
#   facet_wrap(~group)
# 
# ### normality
# data %>% group_by(group, session) %>% shapiro_test(score)
# ggqqplot(data, "score", ggtheme = theme_bw()) + facet_grid(~group)
# 
# ### homoscedasticity
# data %>% levene_test(score ~ group)

### ANOVA
summary(aov(score ~ group, data=data))
pairwise.t.test(data$score, data$group, p.adjust.method="bonferroni")
performance::r2(aov(score ~ group, data=data))

### robust ANOVA (WSR2)
t1waybt(score ~ group, data=data, tr=0.2, nboot=2000)
#mcppb20(score ~ group, data=data, tr=0.2, nboot=2000)

### Kruskal-Wallis test
kruskal.test(score ~ group, data=data)
dunn_test(score ~ group, data=data, p.adjust.method="bonferroni")

```

```{r stats_goal}

data <- pt_data %>% 
  filter(condition=="goals")

# ### histogramm
# ggplot(data, aes(x=score)) +
#   geom_histogram(binwidth=0.1) + 
#   facet_wrap(~group)
#   
# ### normality
# data %>% group_by(group, session) %>% shapiro_test(score)
# ggqqplot(data, "score", ggtheme = theme_bw()) + facet_grid(~group)
# 
# ### homoscedasticity
# data %>% levene_test(score ~ group)

### ANOVA
summary(aov(score ~ group, data=data))
performance::r2(aov(score ~ group, data=data))

### robust ANOVA (WSR2)
t1waybt(score ~ group, data=data, tr=0.2, nboot=2000)

### Kruskal-Wallis test
kruskal.test(score ~ group, data=data)

```