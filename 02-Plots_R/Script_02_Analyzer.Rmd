---
title: "Data analysis for WP10"
author: "Patrizia Maier"
date: "`r format(Sys.time(), '%d %B, %Y')`"
output: html_document
---

```{r setup, include=F, cache=F}

library(tidyverse)
library(janitor)
library(gtsummary)
library(performance)
library(afex)
library(WRS2)
library(lme4)
library(emmeans)
library(car)
library(MASS)
library(rstatix)
library(ggpubr)
library(nlme)
# library(Rcpp)
# library(robustlmm)
# library(multcomp)
# install.packages('tinytex')
# tinytex::install_tinytex() # latex for pdf file creation

# set contrast coding
options(contrasts=c(unordered ="contr.sum", ordered ="contr.poly"))

```


```{r load_data, include=F}
file_name <- "../WP10_data/WP10_results/wp10_navigation_data.RData"
load(file_name)
sm_orig <- sm_data 
rm(file_name)

file_name <- "../WP10_data/WP10_results/wp10_post_nav_data.RData"
load(file_name)
rm(file_name)
```


## Demographics 

Available navigation data 

```{r demo_1, echo=F, message=F, warning=F}
t1 <- sm_data %>% 
  filter(trial_num==1, session==1) %>% 
  select(group, sex) %>%
  tbl_summary(by=group,
              label=list(sex ~ "Gender"),
              statistic=list(all_categorical() ~ "{n}")) %>% 
  modify_header(label="Starmaze data",
                stat_by="**{level}** N = {n}") %>% 
  modify_footnote(everything() ~ NA)
t1
rm(t1)

# t1 %>%
#   as_flex_table() %>%
#   flextable::save_as_docx(path="TEST.docx")
```
 
Available post-navigation data 
 
```{r demo_2, echo=F, message=F, warning=F}
t2 <- pt_data %>% 
  filter(trial_num==1) %>% 
  select(group, sex) %>%
  tbl_summary(by=group,
              label=list(sex ~ "Gender"),
              statistic=list(all_categorical() ~ "{n}")) %>% 
  modify_header(label="Post-navigation data",
                stat_by="**{level}** N = {n}") %>% 
  modify_footnote(everything() ~ NA)
t2
rm(t2)
```


```{r stats_data}

data_l <- sm_data %>%
  filter(exclude_trial_matlab==0) %>% 
  filter(condition %in% c("main_learn")) %>% 
  mutate(trial_in_cond_f=factor(trial_in_cond),
         trial_in_cond_0=trial_in_cond-1,
         block_f=factor(block),
         block_0=block-1,
         goal_f=factor(goal_i),
         goal_identity_f=factor(goal_identity),
         log_time=log(time),
         log_pd=log(path_distance),
         log_ed=log(zone_editdistance),
         log_rot=log(rotation_xyz)) %>% 
  droplevels()

data <- sm_data %>%
  filter(exclude_trial_matlab==0) %>% 
  filter(condition %in% c("allo_ret", "ego_ret")) %>% 
  mutate(session_0=as.integer(session)-1,
         log_time=log(time),
         log_pd=log(path_distance),
         log_ed=log(zone_editdistance),
         log_pd_ch=log(chosen_path_distance)) %>% 
  droplevels()

data_c <- data %>% 
  filter(correct_final_alley==1) %>% 
  mutate(session_0=as.integer(session)-1,
         log_fd=log(final_distance)) %>% 
  droplevels()

```


### Navigation: Learning trials 

```{r stats_hist}

ggplot(data_l, aes(x=time)) +
  geom_histogram() +
  facet_wrap(~group)

ggplot(data_l, aes(x=path_distance)) +
  geom_histogram() +
  facet_wrap(~group)

ggplot(data_l, aes(x=zone_editdistance)) +
  geom_histogram() +
  facet_wrap(~group)

ggplot(data_l, aes(x=rotation_xyz)) +
  geom_histogram() +
  facet_wrap(~group)


# # check distribution
# qqp(data_l$time, "norm")
# qqp(data_l$time, "lnorm")
# gamma <- fitdistr(data_l$time, "gamma")
# qqp(data_l$time, "gamma", shape=gamma$estimate[[1]], rate=gamma$estimate[[2]])

ggplot(data_l %>% filter(id < 12000), aes(x=trial_in_cond, y=time)) +
  geom_point() +
  scale_x_continuous(breaks=1:8) +
  facet_wrap(~id)

```

```{r stats_learning_time}

## 1) gaussian 
lmer.full <- mixed(time ~ (group+block_0+trial_in_cond_0)^2 + 
                     (trial_in_cond_0*block_0|id), data=data_l, 
                   # (trial_in_cond_0|id/block_0), data=data_l,
                   control=lmerControl(optimizer="bobyqa",
                                       optCtrl=list(maxfun=1e6)))
check_model(lmer.full$full_model, panel=F)
# model does converge but diagnostics bad

## 2) gaussian with log-transformed outcome 
lmer.full_log <- mixed(log_time ~ group*block_f*trial_in_cond_f + 
                         (block_f|id), data=data_l, 
                       control=lmerControl(optimizer="bobyqa",
                                           optCtrl=list(maxfun=1e6)))
check_model(lmer.full_log$full_model, panel=F)
# model does converge but diagnostics only ok (some heteroscedasticity)

afex_plot(lmer.full_log, "trial_in_cond_f",  "group", "block_f", id="id",
          data_geom=ggbeeswarm::geom_quasirandom)

# rg=ref_grid(lmer.full_log)
# emmeans(rg, pairwise ~ group, adjust="bonferroni")
# emmeans(rg, pairwise ~ trial_in_cond_f | block_f, adjust="bonferroni")
# emmeans(rg, pairwise ~ c(trial_in_cond_f, group), adjust="bonferroni")

## 3) gaussian with log link: does not converge

## 4) gamma with identity link: does not converge

## 6) inverse gaussian with identity link: does not converge

## 7) robustlmm: not applicable
# rlmer.full <- robustlmm::rlmer(time ~ (group+block_0+trial_in_cond_0)^2 + 
#                             (trial_in_cond_0*block_0|id), data=data_l)
# plot(rlmer.full)

## 8) model heteroscedasticity with nlme
nlme.full <- lme(time ~ (group+block_0+trial_in_cond_0)^2,
                  random=~trial_in_cond_0|id/block_0,
                  correlation=corCAR1(0.5, form=~trial_in_cond_0|id/block_0),
                  data=data_l, method="ML")
check_model(nlme.full, panel=F)

nlme.full_log <- lme(log_time ~ (group+block_0+trial_in_cond_0)^2,
                 random=~trial_in_cond_0|id/block_0,
                  correlation=corCAR1(0.5, form=~trial_in_cond_0|id/block_0),
                 data=data_l, method="ML")
check_model(nlme.full_log, panel=F)

## 9) comparison to standard tests: same effect 
summary(aov(time ~ (group+block_0+trial_in_cond_0)^2, data=data_l))
bwtrim(time ~ group*trial_in_cond_0, id=id, data=data_l, tr=0.2, nboot=2000)
bwtrim(time ~ group*block_0, id=id, data=data_l, tr=0.2, nboot=2000)
bwtrim(time ~ trial_in_cond_0*block_0, id=id, data=data_l, tr=0.2, nboot=2000)

```

```{r stats_learning_others}

### path distance
## 1) gaussian 
lmer.full <- mixed(path_distance ~ (group+block_0+trial_in_cond_0)^2 + 
                     (trial_in_cond_0*block_0|id), data=data_l, 
                   # (trial_in_cond_0|id/block_0), data=data_l,
                   control=lmerControl(optimizer="bobyqa",
                                       optCtrl=list(maxfun=1e6)))
check_model(lmer.full$full_model, panel=F)
# model does converge but diagnostics bad

## 2) gaussian with log-transformed outcome 
lmer.full_log <- mixed(log_pd ~ (group+block_0+trial_in_cond_0)^2 + 
                         (trial_in_cond_0*block_0|id), data=data_l, 
                         #(trial_in_cond_0|id/block_0), data=data_l, 
                       control=lmerControl(optimizer="bobyqa",
                                           optCtrl=list(maxfun=1e6)))
check_model(lmer.full_log$full_model, panel=F)
# model does converge but diagnostics only ok (some heteroscedasticity)

## 8) model heteroscedasticity with nlme
nlme.full <- lme(path_distance ~ (group+block_0+trial_in_cond_0)^2,
                  random=~trial_in_cond_0|id/block_0,
                  correlation=corCAR1(0.5, form=~trial_in_cond_0|id/block_0),
                  data=data_l, method="ML")
check_model(nlme.full, panel=F)

nlme.full_log <- lme(log_pd ~ (group+block_0+trial_in_cond_0)^2,
                 random=~trial_in_cond_0|id/block_0,
                 correlation=corCAR1(0.5, form=~trial_in_cond_0|id/block_0),
                 data=data_l, method="ML")
check_model(nlme.full_log, panel=F)


### path edit distance 
## 2) gaussian with log-transformed outcome 
lmer.full_log <- mixed(log_ed ~ (group+block_0+trial_in_cond_0)^2 + 
                         (trial_in_cond_0*block_0|id), data=data_l, 
                         #(trial_in_cond_0|id/block_0), data=data_l, 
                       control=lmerControl(optimizer="bobyqa",
                                           optCtrl=list(maxfun=1e6)))
check_model(lmer.full_log$full_model, panel=F)
# model does converge but diagnostics bad (heteroscedasticity)

## 8) model heteroscedasticity with nlme
nlme.full_log <- lme(log_ed ~ (group+block_0+trial_in_cond_0)^2,
                 random=~trial_in_cond_0|id/block_0,
                 correlation=corCAR1(0.5, form=~trial_in_cond_0|id/block_0),
                 data=data_l, method="ML")
check_model(nlme.full_log, panel=F)


## rotation 
## 1) gaussian 
lmer.full <- mixed(rotation_xyz ~ (group+block_0+trial_in_cond_0)^2 + 
                     (trial_in_cond_0*block_0|id), data=data_l, 
                   # (trial_in_cond_0|id/block_0), data=data_l,
                   control=lmerControl(optimizer="bobyqa",
                                       optCtrl=list(maxfun=1e6)))
check_model(lmer.full$full_model, panel=F)
# model does converge but diagnostics bad

## 8) model heteroscedasticity with nlme
nlme.full_log <- lme(rotation_xyz ~ (group+block_0+trial_in_cond_0)^2,
                 random=~trial_in_cond_0|id/block_0,
                 correlation=corCAR1(0.5, form=~trial_in_cond_0|id/block_0),
                 data=data_l, method="ML")
check_model(nlme.full_log, panel=F)

```


### Navigation: Probe trials 

```{r stats_correct}

### correct final alley (binomial): results currently not stable ! 

# full model with random intercept, slope and correlations: does not converge 
mixed.full <- mixed(correct_final_alley ~ group*session*condition +
                      (session*condition|id), data=data, 
                    family=binomial(link="logit"), method="LRT",
                    control=glmerControl(optimizer="bobyqa",
                                         optCtrl=list(maxfun=1e6)))

# full model with random intercept and slope, no correlations: does converge
mixed.red_0 <- mixed(correct_final_alley ~ group*session_0*condition +
                     (session_0*condition||id), data=data, expand_re=T,
                   family=binomial(link="logit"), method="LRT",
                   control=glmerControl(optimizer="bobyqa",
                                        optCtrl=list(maxfun=1e6)))

mixed.red <- mixed(correct_final_alley ~ group*session*condition +
                     (session*condition||id), data=data, expand_re=T,
                   family=binomial(link="logit"), method="LRT",
                   control=glmerControl(optimizer="bobyqa",
                                        optCtrl=list(maxfun=1e6)))

# # plots for random effects
# lattice::dotplot(ranef(mixed.red$full_model, condV=TRUE))

# # post-test with fixed effects
# afex_plot(mixed.red, "session", "group", "sex", id = "id",
#           data_geom = ggbeeswarm::geom_quasirandom)
# afex_plot(mixed.red, "session", "group", "condition", id = "id",
#           data_geom = ggbeeswarm::geom_quasirandom)

# emmeans(mixed.red, pairwise ~ group, type="response", adjust="bonferroni")
# emmeans(mixed.red, pairwise ~ session, type="response")

```

```{r stats_finaldistance}

### path distance
## 1) gaussian
# full model: does not converge 
lmer.full <- mixed(final_distance ~ group*session*condition + 
                     (session*condition|id), data=data_c, 
                   control=lmerControl(optimizer="bobyqa",
                                       optCtrl=list(maxfun=1e6)))
check_model(lmer.full$full_model, panel=F)

# reduced model:
lmer.red <- mixed(final_distance ~ group*session*condition + 
                    (session|id), data=data_c, expand_re=T,
                  control=lmerControl(optimizer="bobyqa",
                                      optCtrl=list(maxfun=1e6)))
check_model(lmer.red$full_model, panel=F)
# model does converge but diagnostics bad

## 2) gaussian with log-transformed outcome 
lmer.red_log <- mixed(log_fd ~ group*session*condition + 
                        (session|id), data=data_c, 
                      control=lmerControl(optimizer="bobyqa",
                                          optCtrl=list(maxfun=1e6)))
check_model(lmer.red_log$full_model, panel=F)
# model does converge and diagnostics good :-)

lmer.red_log$anova_table
emmeans(lmer.red_log, pairwise ~ group, adjust="bonferroni")
emmeans(lmer.red_log, pairwise ~ session)
afex_plot(lmer.red_log,  "session", "group", "condition", id = "id",
          data_geom = ggbeeswarm::geom_quasirandom)

# ## 8) model heteroscedasticity with nlme
# nlme.full_log <- lme(log_fd ~ group*session*condition,  
#                      random=~1|id, data=data_c, 
#                      correlation=corAR1(0, form=~session|id),
#                      method="ML")
# check_model(nlme.full_log, panel=F)

```


### Post-navigation memory test

```{r stats_layout}

data <- pt_data %>% 
  filter(condition=="layout")

fisher.test(table(data$score, data$group))
pairwise_fisher_test(table(data$score, data$group), p.adjust.method="bonferroni")

```

```{r stats_gmda}

data <- pt_data %>% 
  filter(condition=="position")

# ### histogramm
# ggplot(data, aes(x=score)) +
#   geom_histogram(binwidth=0.1) + 
#   facet_wrap(~group)
#   
# ### normality
# data %>% group_by(group, session) %>% shapiro_test(score)
# ggqqplot(data, "score", ggtheme = theme_bw()) + facet_grid(~group)
# 
# ### homoscedasticity
# data %>% levene_test(score ~ group)

### ANOVA
summary(aov(score ~ group, data=data))
pairwise.t.test(data$score, data$group, p.adjust.method="bonferroni")
performance::r2(aov(score ~ group, data=data))

### robust ANOVA (WSR2)
t1waybt(score ~ group, data=data, tr=0.2, nboot=2000)
mcppb20(score ~ group, data=data, tr=0.2, nboot=2000)

### Kruskal-Wallis test 
kruskal.test(score ~ group, data=data)
dunn_test(score ~ group, data=data, p.adjust.method="bonferroni")

```

```{r stats_landmark}
data <- pt_data %>% 
  filter(condition=="landmarks")

# ### histogramm
# ggplot(data, aes(x=score)) +
#   geom_histogram(binwidth=0.1) +
#   facet_wrap(~group)
# 
# ### normality
# data %>% group_by(group, session) %>% shapiro_test(score)
# ggqqplot(data, "score", ggtheme = theme_bw()) + facet_grid(~group)
# 
# ### homoscedasticity
# data %>% levene_test(score ~ group)

### ANOVA
summary(aov(score ~ group, data=data))
pairwise.t.test(data$score, data$group, p.adjust.method="bonferroni")
performance::r2(aov(score ~ group, data=data))

### robust ANOVA (WSR2)
t1waybt(score ~ group, data=data, tr=0.2, nboot=2000)
#mcppb20(score ~ group, data=data, tr=0.2, nboot=2000)

### Kruskal-Wallis test
kruskal.test(score ~ group, data=data)
dunn_test(score ~ group, data=data, p.adjust.method="bonferroni")

```

```{r stats_goal}

data <- pt_data %>% 
  filter(condition=="goals")

# ### histogramm
# ggplot(data, aes(x=score)) +
#   geom_histogram(binwidth=0.1) + 
#   facet_wrap(~group)
#   
# ### normality
# data %>% group_by(group, session) %>% shapiro_test(score)
# ggqqplot(data, "score", ggtheme = theme_bw()) + facet_grid(~group)
# 
# ### homoscedasticity
# data %>% levene_test(score ~ group)

### ANOVA
summary(aov(score ~ group, data=data))
performance::r2(aov(score ~ group, data=data))

### robust ANOVA (WSR2)
t1waybt(score ~ group, data=data, tr=0.2, nboot=2000)

### Kruskal-Wallis test
kruskal.test(score ~ group, data=data)

```