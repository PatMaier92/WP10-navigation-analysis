---
title: "Data analysis for WP10"
author: "Patrizia Maier"
date: "`r format(Sys.time(), '%d %B, %Y')`"
output: html_document
---

```{r setup, include=F, cache=F}

library(tidyverse)
library(janitor)
library(gtsummary)
library(performance)
library(rstatix)
library(ggpubr)
library(WRS2)
# library(WRS) # alternative: # source("Rallfun-v40.txt") # for WRS
library(afex)
library(lme4)
library(nlme)
# library(lmeresampler)
# library(parameters)
# library(lavaSearch2)
library(emmeans)
library(car)
library(DHARMa)
# install.packages('tinytex')
# tinytex::install_tinytex() # latex for pdf file creation

# set contrast coding
options(contrasts=c(unordered="contr.sum", ordered="contr.poly"))
# options("contrasts")
# options(contrasts=c(unordered="contr.treatment", ordered="contr.poly"))

```


```{r load_data, include=F}
file_name <- "../WP10_data/WP10_results/wp10_navigation_data.RData"
load(file_name)
sm_orig <- sm_data 
rm(file_name)

file_name <- "../WP10_data/WP10_results/wp10_post_nav_data.RData"
load(file_name)
rm(file_name)
```


### Demographics 

##### Available navigation data 

```{r demo_1, echo=F, message=F, warning=F}
t1 <- sm_data %>% 
  filter(trial==1, session==1) %>% 
  select(group, sex) %>%
  tbl_summary(by=group,
              label=list(sex ~ "Gender"),
              statistic=list(all_categorical() ~ "{n}")) %>% 
  modify_header(label="Starmaze data",
                stat_by="**{level}** N = {n}") %>% 
  modify_footnote(everything() ~ NA)
t1
rm(t1)

# t1 %>%
#   as_flex_table() %>%
#   flextable::save_as_docx(path="TEST.docx")
```
 
##### Available post-navigation data 
 
```{r demo_2, echo=F, message=F, warning=F}
t2 <- pt_data %>% 
  filter(trial==4) %>% 
  select(group, sex) %>%
  tbl_summary(by=group,
              label=list(sex ~ "Gender"),
              statistic=list(all_categorical() ~ "{n}")) %>% 
  modify_header(label="Post-navigation data",
                stat_by="**{level}** N = {n}") %>% 
  modify_footnote(everything() ~ NA)
t2
rm(t2)
```


```{r stats_data}

## practise motor control
data_p <- sm_data %>%
  filter(condition %in% c("practise")) %>%  
  select(id, group, sex, time, path_length, velocity) %>% 
  droplevels()

## learning
data_l <- sm_data %>%
  filter(exclude_trial_matlab==0) %>% 
  filter(condition %in% c("main_learn")) %>% 
  mutate(trial_in_cond_f=factor(trial_in_cond),
         trial_in_cond_0=trial_in_cond-1,
         trial_in_cond_c=trial_in_cond-4.5,
         block_f=factor(block)) %>% 
  droplevels()

## probe 
data <- sm_data %>% 
  filter(exclude_trial_matlab==0) %>% 
  filter(condition %in% c("allo_ret", "ego_ret")) %>% 
  droplevels()

data_1 <- data %>% 
  filter(session==1) %>% 
  droplevels()

## probe correct trials 
data_c <- data %>% 
  filter(correct_final_alley==1) %>% 
  droplevels()

data_c_1 <- data_c %>% 
  filter(session==1) %>% 
  droplevels()

## change 
data_prepost <- data %>% 
  select(id, group, session, trial, condition, correct_final_alley) %>%
  pivot_wider(id_cols=c(id, trial, group, condition),
              names_from=session,
              names_prefix="s_",
              values_from=correct_final_alley) %>%
  group_by(id, group, condition) %>%
  summarise_at(vars(s_1, s_2), mean, na.rm=T) %>% 
  mutate(change_diff=s_2-s_1,
         change_rel=s_2/s_1,
         change_reldiff=(s_2-s_1)/s_1) %>% 
  ungroup() %>% 
  droplevels()

```


### Navigation
#### Motor control trial 

```{r stats_motor_control}

# ::: METHOD: single value per person, therefore (robust) ANOVA ::: #

# time: GROUPS DIFFER SIGNIFICANTLY 
t1way(time ~ group, data=data_p, tr=0.2, alpha=0.05, nboot=1000)
lincon(time ~ group, data=data_p, tr=0.2, alpha=0.05,  nboot=1000, method="bonferroni") # default: hochberg

# path length: GROUPS DIFFER SIGNIFICANTLY
t1way(path_length ~ group, data=data_p, tr=0.2, alpha=0.05, nboot=1000)
lincon(path_length ~ group, data=data_p, tr=0.2, alpha=0.05,  nboot=1000, method="bonferroni")

# velocity: no differences 
t1way(velocity ~ group, data=data_p, tr=0.2, alpha=0.05, nboot=1000)
lincon(velocity ~ group, data=data_p, tr=0.2, alpha=0.05,  nboot=1000, method="bonferroni")

# ::: MEANING: during practise, the younger the participants, the longer they take to complete the trial and the more they deviate from an ideal path (i.e. difficulties with joystick motor control) --> include time, path length and/or velocity as covariate ::: #

```

#### Learning trials 

```{r stats_learning}

# ::: METHOD: per person 8 trials ? 3 blocks (= 24 trials) with continuous outcome, therefore lmm model ::: #
# watch out for convergence (stepwise reduction of random effects), normality of residuals, homoscedasticity and outliers # 

## -- time -- ##
# 1) standard lmer model 
# contrasts set to sum-coding by mixed
learn.time <- mixed(time ~ group*block_f*trial_in_cond_c + (block_f|id), 
                    data=data_l, expand_re=T,
                    control=lmerControl(optimizer="bobyqa", optCtrl=list(maxfun=1e6)))
# check model
simulationOutput <- simulateResiduals(fittedModel=learn.time$full_model, plot=F)
testResiduals(simulationOutput)
plotResiduals(simulationOutput)
testCategorical(simulationOutput, catPred=data_l$group)
# model diagnostics are bad


# 2) advanced lme models with variance estimation 
learn.time_base <- lme(time ~ group*block_f*trial_in_cond_c,
                       random=~1+block_f | id, 
                       data=data_l, method="ML")
learn.time_var1 <- update(learn.time_base, weights=varIdent(form=~1 | group))
# learn.time_var2 <- update(learn.time_base, weights=varComb(varIdent(form=~1 | group),
#                                                            varIdent(form=~1 | block_f)))
anova.lme(learn.time_base, learn.time_var1)
# chose model 1

# diagnostics: naja 
plot(learn.time_var1, resid(., type="p") ~ fitted(.), abline=0)
plot(learn.time_var1, group ~ resid(., type="p"))
plot(learn.time_var1, block_f ~ resid(., type="p"))
qqnorm(resid(learn.time_var1))
qqline(resid(learn.time_var1))

# re fit with REML
learn.time_final = update(learn.time_var1, method="REML")

# statistics 
anova.lme(learn.time_final, type="marginal", adjustSigma=T)
emtrends(learn.time_final, pairwise ~ block_f, var="trial_in_cond_c", adjust="bonferroni")
emtrends(learn.time_final, pairwise ~ group, var="trial_in_cond_c", adjust="bonferroni")
emmeans(learn.time_final, pairwise ~ group, type="response", adjust="bonferroni")

# # extract estimated variance
# variance <- learn.time_var$modelStruct$varStruct %>%
#   coef(unconstrained = FALSE, allCoef = TRUE) %>%
#   enframe(name = "grp", value = "varStruct") %>%
#   mutate(sigma         = learn.time_var$sigma) %>%
#   mutate(StandardError = sigma * varStruct) %>%
#   mutate(Variance      = StandardError ^ 2)


## -- path metric distance -- ##
## 1) standard lme model without variance estimation 
learn.path_base <- lme(path_distance ~ group*block_f*trial_in_cond_c,
                       random=~1+block_f | id, 
                       data=data_l, method="ML")

## 2) advanced lme models withvariance estimation 
learn.path_var1 <- update(learn.path_base, weights=varIdent(form=~1 | group))
learn.path_var2 <- update(learn.path_base, weights=varComb(varIdent(form=~1 | group),
                                                           varIdent(form=~1 | block_f)))
anova(learn.path_base, learn.path_var1, learn.path_var2, test=T) 
# chose model 2 (or model 1)

# diagnostics: ok 
plot(learn.path_var2, resid(., type="p") ~ fitted(.), abline=0)
qqnorm(resid(learn.path_var2))
qqline(resid(learn.path_var2))

# re-fit with REML
learn.path_final <- update(learn.path_var2, method="REML")

# statistics 
anova.lme(learn.path_final, type="marginal", adjustSigma=T)
emtrends(learn.path_final, pairwise ~ block_f, var="trial_in_cond_c", adjust="bonferroni")
emtrends(learn.path_final, pairwise ~ group, var="trial_in_cond_c", adjust="bonferroni")
emmeans(learn.path_final, pairwise ~ group, type="response", adjust="bonferroni")


## -- path edit distance -- ##
# TBD: count data? consider poisson model (glmmTMB or lmer, not lme)
## 1) standard lme model without variance estimation 
learn.edit_base <- lme(path_edit_distance ~ group*block_f*trial_in_cond_c,
                       random=~1+block_f | id, 
                       data=data_l, method="ML")

## 2) advanced lme models withvariance estimation
learn.edit_var1 <- update(learn.edit_base, weights=varIdent(form=~1 | group))
# learn.edit_var2 <- update(learn.edit_base, weights=varComb(varIdent(form=~1 | group),
#                                                            varIdent(form=~1 | block_f)))
anova(learn.edit_base, learn.edit_var1) 
# chose model 1 

# diagnostics: naja 
plot(learn.edit_var1, resid(., type="p") ~ fitted(.), abline=0)
qqnorm(resid(learn.edit_var1))
qqline(resid(learn.edit_var1))

# re-fit with REML
learn.edit_final <- update(learn.edit_var1, method="REML")

# statistics 
anova.lme(learn.edit_final, type="marginal", adjustSigma=T)
emtrends(learn.edit_final, pairwise ~ block_f, var="trial_in_cond_c", adjust="bonferroni")
emtrends(learn.edit_final, pairwise ~ group, var="trial_in_cond_c", adjust="bonferroni")
emmeans(learn.edit_final, pairwise ~ group, type="response", adjust="bonferroni")


## -- target metric distance -- ##


## -- rotation  -- ##


```

#### Probe trials 

```{r stats_probe_accuracy}

# ::: METHOD: several trials p. p. (session, condition) with binomial outcome, therefore glmm model ::: #
# watch out for convergence (stepwise reduction of random effects) # 

## -- correct final alley -- ##
# **** sessions T1 & T2 **** # 
# 1) full binomial model (with reduced random effects due to failed convergence)
probe.acc <- mixed(correct_final_alley ~ group*session*condition + 
                     (session*condition||id), data=data, expand_re=T,
                   family=binomial(link="logit"), method="LRT",
                   control=glmerControl(optimizer="bobyqa", optCtrl=list(maxfun=1e6)))

# check model: ok 
simulationOutput <- simulateResiduals(fittedModel=probe.acc$full_model, plot=F)
testResiduals(simulationOutput) 
plotResiduals(simulationOutput) 
testCategorical(simulationOutput, catPred=data$group[data$exclude_trial_matlab==0])
testCategorical(simulationOutput, catPred=data$session[data$exclude_trial_matlab==0])
testCategorical(simulationOutput, catPred=data$condition[data$exclude_trial_matlab==0])

# post-test for fixed effects
afex_plot(probe.acc, "session", "group", "condition", id = "id",
          data_geom = ggbeeswarm::geom_quasirandom)

probe.acc
emmeans(probe.acc, pairwise ~ group, type="response", adjust="bonferroni")
emmeans(probe.acc, pairwise ~ session, type="response")
emmeans(probe.acc, pairwise ~ condition, type="response")


# **** sessions T1 only **** # 
# 1) full binomial model
probe.acc_1 <- mixed(correct_final_alley ~ group*condition + 
                       (condition|id), data=data_1, expand_re=T,
                     family=binomial(link="logit"), method="LRT",
                     control=glmerControl(optimizer="bobyqa", optCtrl=list(maxfun=1e6)))

simulationOutput <- simulateResiduals(fittedModel=probe.acc_1$full_model, plot=F)
testResiduals(simulationOutput) 
plotResiduals(simulationOutput) 
testCategorical(simulationOutput, catPred=data_1$group)
testCategorical(simulationOutput, catPred=data_1$condition)

# post-test for fixed effects
afex_plot(probe.acc_1, "group", "condition", id = "id",
          data_geom = ggbeeswarm::geom_quasirandom)

probe.acc
emmeans(probe.acc_1, pairwise ~ group, type="response", adjust="bonferroni")

# ::: MEANING: Significant differences between age groups (the older, the better), sessions (s1 better than s2) and slight difference between conditions (ego slightly better than allo), no interactions ::: #

```

```{r stats_probe_accuracy_change}

# ::: METHOD: one aggregated value per person, therefore (robust) ANOVA ::: #  

# --- change relative difference --- # 
# 1) standard ANOVA
# contrasts are set to sum by default
aov.change <- aov_car(change_reldiff ~ group*condition + Error(id/condition), data=data_prepost)
qqPlot(data_prepost$change_reldiff) # non-normality
data_prepost %>% shapiro_test(change_reldiff) 
plot(predict(aov.change), residuals(aov.change), main="Residuals vs. Predicted") # homoscedasticity ok
data_prepost %>% levene_test(change_reldiff ~ group) 
summary(aov.change)
emmeans(aov.change, pairwise ~ group | condition, adjust="bonferroni")


# 2) robust ANOVA from WRS/WRS2 
# contrasts are set to sum by default (I think)
# # robust mixed anova 
raov.change <- bwtrim(change_reldiff ~ group*condition, id=id, data=data_prepost, tr=0.2)
# # alternative to trim: mom-esitmator
# sppba(change_reldiff ~ group*condition, id=id, data=data_prepost, est="mom", avg=TRUE, nboot=500, MDIS=FALSE)
# sppbb(change_reldiff ~ group*condition, id=id, data=data_prepost, est="mom", avg=TRUE, nboot=500)
# sppbi(change_reldiff ~ group*condition, id=id, data=data_prepost, est="mom", avg=TRUE, nboot=500)
raov.change
# using one-way post-test lincon() because no dedicated post-test for bwtrim() 
lincon(change_reldiff ~ group, data=data_prepost, tr=0.2, alpha=0.05, method="bonferroni")


# ::: MEANING: Some evidence in favor of consolidation differences between children and adults. However, effect was found only in robust and not in standard ANOVA. There was also no significant group*session interaction in the previous analysis. Does this make sense? ::: #

```

```{r stats_probe_final_distance}

# ::: METHOD: several trials p. p. (session, condition) with metric (but possibly non-gaussian) outcome, therefore lmm model. Check if modelling of variance (heteroscedasticity) improves model significantly, i.e. use (n)lme instead of lmer/mixed. Disadvantages are that no non-gaussian distributions and potentially anti-conservative p-values (no Satterthwaite/Kenward-Roger df correction) ::: 


## -- final distance in correct trials -- ##
# **** sessions T1 & T2 **** # 
## 1) standard lme model without variance estimation 
probe.fd_correct <- lme(final_distance ~ group*session*condition,
                       random=list(id=pdDiag(~ condition * session)), 
                       data=data_c, method="ML")
anova(probe.fd_correct)

# diagnostics: non-normality, largest heterogenity between groups, less between condition & session 
plot(probe.fd_correct, resid(., type="p") ~ fitted(.))
plot(probe.fd_correct, group ~ resid(., type="p"))
plot(probe.fd_correct, condition ~ resid(., type="p"))
plot(probe.fd_correct, session ~ resid(., type="p"))
qqnorm(resid(probe.fd_correct))
qqline(resid(probe.fd_correct))


## 2) advanced lme models with variance estimation
probe.fd_correct_var1 <- update(probe.fd_correct, weights=varIdent(form=~1 | group))
# probe.fd_correct_var2 <- update(probe.fd_correct, weights=varComb(varIdent(form=~1 | group),
#                                                                   varIdent(form=~1 | condition)))
probe.fd_correct_var3 <- update(probe.fd_correct, weights=varComb(varIdent(form=~1 | group),
                                                                  varIdent(form=~1 | session)))
anova(probe.fd_correct, probe.fd_correct_var1, probe.fd_correct_var3, test=T) 
# chose model 3 based on convergence with this random effects structure & information criteria

# diagnostics: ok 
plot(probe.fd_correct_var3, resid(., type="p") ~ fitted(.), abline=0)
qqnorm(resid(probe.fd_correct_var3))
qqline(resid(probe.fd_correct_var3))

# re-fit final model with with REML
probe.fd_correct_final <- update(probe.fd_correct_var3, method="REML")

# statistics 
anova(probe.fd_correct_final, type="marginal", adjustSigma=T)
emmeans(probe.fd_correct_final, pairwise ~ group, adjust="bonferroni")
emmeans(probe.fd_correct_final, pairwise ~ session)


# **** sessions T1 only **** # 
## 1) standard lme model without variance estimation 
probe.fd_correct_1 <- lme(final_distance ~ group*condition,
                          random=list(id=pdDiag(~ condition)),
                          data=data_c_1, method="ML")

# diagnostics: non-normality, largest heterogenity between groups, less between conditions 
plot(probe.fd_correct_1, resid(., type="p") ~ fitted(.))
plot(probe.fd_correct_1, group ~ resid(., type="p"))
plot(probe.fd_correct_1, condition ~ resid(., type="p"))
qqnorm(resid(probe.fd_correct_1))
qqline(resid(probe.fd_correct_1))


## 2) advanced lme models with variance estimation
probe.fd_correct_1_var1 <- update(probe.fd_correct_1, weights=varIdent(form=~1 | group))
# probe.fd_correct_1_var2 <- update(probe.fd_correct_1, weights=varComb(varIdent(form=~1 | group),
#                                                                        varIdent(form=~1 | condition)))
anova(probe.fd_correct_1, probe.fd_correct_1_var1, test=T) 
# chose model 1 based on convergence with this random effects structure & information criteria

# diagnostics: ok 
plot(probe.fd_correct_1_var1, resid(., type="p") ~ fitted(.), abline=0)
qqnorm(resid(probe.fd_correct_1_var1))
qqline(resid(probe.fd_correct_1_var1))

# re-fit final model with with REML
probe.fd_correct_1_final <- update(probe.fd_correct_1_var1, method="REML")

# statistics 
anova(probe.fd_correct_1_final, type="marginal", adjustSigma=T)
emmeans(probe.fd_correct_1_final, pairwise ~ group, adjust="bonferroni")


## -- final distance in relation to local environment (boundary) for all trials -- ##
# **** sessions T1 & T2 **** # 
## 1) standard lme model without variance estimation 
probe.fd_local <- lme(final_local_distance ~ group*session*condition,
                      random=list(id=pdDiag(~ condition * session)),
                      data=data, na.action=na.omit, method="ML")

# diagnostics: non-normality, largest heterogenity between groups, then sessions, then conditions 
plot(probe.fd_local, resid(., type="p") ~ fitted(.))
plot(probe.fd_local, group ~ resid(., type="p"))
plot(probe.fd_local, condition ~ resid(., type="p"))
plot(probe.fd_local, session ~ resid(., type="p"))
qqnorm(resid(probe.fd_correct_1))
qqline(resid(probe.fd_correct_1))


## 2) advanced lme models withvariance estimation
probe.fd_local_var1 <- update(probe.fd_local, weights=varIdent(form=~1 | group))
probe.fd_local_var2 <- update(probe.fd_local, weights=varComb(varIdent(form=~1 | group),
                                                              varIdent(form=~1 | session)))
# probe.fd_local_var3 <- update(probe.fd_local, weights=varComb(varIdent(form=~1 | group),
#                                                               varIdent(form=~1 | condition)))
# probe.fd_local_var4 <- update(probe.fd_local, weights=weights=varComb(varIdent(form=~1 | group),
#                                                               varIdent(form=~1 | session),
#                                                               varIdent(form=~1 | condition)))
anova(probe.fd_local, probe.fd_local_var1, probe.fd_local_var2, test=T) 
# chose model 2 

# diagnostics
plot(probe.fd_local_var2, resid(., type="p") ~ fitted(.), abline=0)
qqnorm(resid(probe.fd_local_var2))
qqline(resid(probe.fd_local_var2))

# re-fit final model with with REML
probe.fd_local_final <- update(probe.fd_local_var2, method="REML")

# statistics 
anova(probe.fd_local_final, type="marginal", adjustSigma=T)
emmeans(probe.fd_local_final, pairwise ~ group, adjust="bonferroni")
emmeans(probe.fd_local_final, pairwise ~ session)


# **** sessions T1 only **** # 
## 1) standard lme model without variance estimation 
probe.fd_local_1 <- lme(final_local_distance ~ group*condition,
                       random=list(id=pdDiag(~ condition)),
                       data=data_c_1, na.action=na.omit, method="ML")

## 2) advanced lme models withvariance estimation
probe.fd_local_1_var1 <- update(probe.fd_local_1, weights=varIdent(form=~1 | group))
# probe.fd_local_1_var2 <- update(probe.fd_local_1, weights=varComb(varIdent(form=~1 | group),
#                                                                   varIdent(form=~1 | condition)))
anova(probe.fd_local_1, probe.fd_local_1_var1, test=T) 
# chose model 1 

# diagnostics
plot(probe.fd_local_1_var1, resid(., type="p") ~ fitted(.), abline=0)
qqnorm(resid(probe.fd_local_1_var1))
qqline(resid(probe.fd_local_1_var1))

# re-fit final model with with REML
probe.fd_local_1_final <- update(probe.fd_local_1_var1, method="REML")

# statistics 
anova(probe.fd_local_1_final, type="marginal", adjustSigma=T)
emmeans(probe.fd_local_1_final, pairwise ~ group, adjust="bonferroni")


# ::: MEANING: No significant interactions (in alignment with accuracy analysis) but group and session main effects ::: #

```

```{r stats_probe_time}

# ::: METHOD: several trials p. p. (session, condition) with metric (but possibly non-gaussian) outcome, therefore lmm model. Check if modelling of variance (heteroscedasticity) improves model significantly, i.e. use (n)lme instead of lmer/mixed. Disadvantages are that no non-gaussian distributions and potentially anti-conservative p-values (no Satterthwaite/Kenward-Roger df correction) ::: 

## -- time -- ##
# **** sessions T1 & T2 **** # 
## 1) standard lme model without variance estimation 
probe.time <- lme(time ~ group*session*condition,
                  random=list(id=pdDiag(~ condition * session)),
                  data=data, method="ML")

# diagnostics: non-normality, largest heterogenity between groups, then conditions, then sessions 
plot(probe.time, resid(., type="p") ~ fitted(.))
plot(probe.time, group ~ resid(., type="p"))
plot(probe.time, condition ~ resid(., type="p"))
plot(probe.time, session ~ resid(., type="p"))
qqnorm(resid(probe.time))
qqline(resid(probe.time))


## 2) advanced lme model withvariance estimation
probe.time_var1 <- update(probe.time, weights=varIdent(form=~1 | group))
probe.time_var2 <- update(probe.time,  weights=varComb(varIdent(form=~1 | group),
                                                       varIdent(form=~1 | condition)))
probe.time_var3 <- update(probe.time,  weights=varComb(varIdent(form=~1 | group),
                                                       varIdent(form=~1 | session)))
probe.time_var4 <- update(probe.time,  weights=varComb(varIdent(form=~1 | group),
                                                       varIdent(form=~1 | session),
                                                       varIdent(form=~1 | condition)))
anova(probe.time, probe.time_var1, probe.time_var2, probe.time_var3, probe.time_var4, test=F) 
anova(probe.time, probe.time_var1, probe.time_var2, probe.time_var4, test=T) 
# chose model 4 (or model 2)

# diagnostics: naja 
plot(probe.time_var4, resid(., type="p") ~ fitted(.), abline=0)
qqnorm(resid(probe.time_var4))
qqline(resid(probe.time_var4))

# re-fit final model with with REML
probe.time_final <- update(probe.time_var4, method="REML")

# statistics 
anova(probe.time_final, type="marginal", adjustSigma=T)
emmeans(probe.time_final, pairwise ~ group | condition | session, adjust="bonferroni")


# **** sessions T1 only **** # 
## 1) standard lme model without variance estimation 
probe.time_1 <- lme(time ~ group*condition,
                    random=list(id=pdDiag(~ condition)),
                    data=data_1, method="ML")

# diagnostics: non-normality, largest heterogenity between groups, then conditions
plot(probe.time_1, resid(., type="p") ~ fitted(.), abline=0)
plot(probe.time_1, group ~ resid(., type="p"))
plot(probe.time_1, condition ~ resid(., type="p"))
qqnorm(resid(probe.time_1))
qqline(resid(probe.time_1))


## 2) advanced lme model with variance estimation
probe.time_1_var1 <- update(probe.time_1, weights=varIdent(form=~1 | group))
probe.time_1_var2 <- update(probe.time_1, weights=varComb(varIdent(form=~1 | group),
                                                         varIdent(form=~1 | condition)))
anova(probe.time_1, probe.time_1_var1, probe.time_1_var2, test=T) 
# chose model 2

# diagnostics: naja
plot(probe.time_1_var2, resid(., type="p") ~ fitted(.), abline=0)
qqnorm(resid(probe.time_1_var2))
qqline(resid(probe.time_1_var2))

# re-fit final model with with REML
probe.time_1_final <- update(probe.time_1_var2, method="REML")

# statistics 
anova(probe.time_1_final, type="marginal", adjustSigma=T)
emmeans(probe.time_1_final, pairwise ~ group | condition, adjust="bonferroni")
emmeans(probe.time_1_final, pairwise ~ condition | group, adjust="bonferroni")


# ::: MEANING: Strong group and condition main effects, no session main effect and some (potentially instable, because barely significant) interaction effects (e.g. stronger time group differences in allocentric compared to egocentric). Explore further/make sure not anti-conservative ::: #

```

``` {r stats_probe_path}

# ::: METHOD: several trials p. p. (session, condition) with metric (but possibly non-gaussian) outcome, therefore lmm model. Check if modelling of variance (heteroscedasticity) improves model significantly, i.e. use (n)lme instead of lmer/mixed. Disadvantages are that no non-gaussian distributions and potentially anti-conservative p-values (no Satterthwaite/Kenward-Roger df correction) ::: 

# TBD: UPDATE FITTING PROCEDURE, SEE ABOVE

## -- path distance  to chosen -- ##
# **** sessions T1 & T2 **** # 
## 1) standard lme model without variance estimation 

probe.ch_path <- lme(chosen_path_distance ~ group*session*condition,
                     random=list(id=pdDiag(~ condition + session)),
                     data=data, method="ML")

## 2) advanced lme model withvariance estimation

probe.ch_path_var <- update(probe.ch_path, weights=varIdent(form=~1 | group))
anova(probe.ch_path, probe.ch_path_var) 

# diagnostics
plot(probe.ch_path_var, resid(., type="p") ~ fitted(.))
plot(probe.ch_path_var, resid(., type="p") ~ fitted(.) | group)
plot(probe.ch_path_var, group ~ resid(., type="p"))
qqnorm(resid(probe.ch_path_var))
qqline(resid(probe.ch_path_var))

# TBD: refit with REML

# statistics 
anova(probe.ch_path_var, type="marginal", adjustSigma=T)
emmeans(probe.ch_path_var, pairwise ~ group | condition, adjust="bonferroni")
emmeans(probe.ch_path_var, pairwise ~ group | session, adjust="bonferroni")


# **** sessions T1 only **** # 
## 1) standard lme model without variance estimation 

probe.ch_path_1 <- lme(chosen_path_distance ~ group*condition,
                       random=list(id=pdDiag(~ condition)),
                       data=data_1, method="ML")

## 2) advanced lme model withvariance estimation

probe.ch_path_var_1 <- update(probe.ch_path_1, weights=varIdent(form=~1 | group))
anova(probe.ch_path_1, probe.ch_path_var_1) 

# diagnostics
plot(probe.ch_path_var_1, resid(., type="p") ~ fitted(.))
plot(probe.ch_path_var_1, resid(., type="p") ~ fitted(.) | group)
plot(probe.ch_path_var_1, group ~ resid(., type="p"))
qqnorm(resid(probe.ch_path_var_1))
qqline(resid(probe.ch_path_var_1))

# TBD: refit with REML

# statistics 
anova(probe.ch_path_var_1, type="marginal", adjustSigma=T)
emmeans(probe.ch_path_var_1, pairwise ~ group | condition, adjust="bonferroni")



## -- target distance -- ##
# **** sessions T1 & T2 **** # 
## 1) standard lme model without variance estimation 

probe.distance_target <- lme(target_distance_error ~ group*session*condition,
                             random=list(id=pdDiag(~ condition + session)),
                             data=data, method="ML")

## 2) advanced lme model withvariance estimation

probe.distance_target_var <- update(probe.distance_target, weights=varIdent(form=~1 | group))
anova(probe.distance_target, probe.distance_target_var) 

# diagnostics
plot(probe.distance_target_var, resid(., type="p") ~ fitted(.))
plot(probe.distance_target_var, resid(., type="p") ~ fitted(.) | group)
plot(probe.distance_target_var, group ~ resid(., type="p"))
qqnorm(resid(probe.distance_target_var))
qqline(resid(probe.distance_target_var))

# TBD: refit with REML

# statistics 
anova(probe.distance_target_var, type="marginal", adjustSigma=T)
emmeans(probe.distance_target_var, pairwise ~ group | condition, adjust="bonferroni")
emmeans(probe.distance_target_var, pairwise ~ session | condition, adjust="bonferroni")


# **** sessions T1 only **** # 
## 1) standard lme model without variance estimation 

probe.distance_target_1 <- lme(target_distance_error ~ group*condition,
                             random=list(id=pdDiag(~ condition)),
                             data=data_1, method="ML")

## 2) advanced lme model withvariance estimation

probe.distance_target_var_1 <- update(probe.distance_target_1, weights=varIdent(form=~1 | group))
anova(probe.distance_target_1, probe.distance_target_var_1) 

# diagnostics
plot(probe.distance_target_var_1, resid(., type="p") ~ fitted(.))
plot(probe.distance_target_var_1, resid(., type="p") ~ fitted(.) | group)
plot(probe.distance_target_var_1, group ~ resid(., type="p"))
qqnorm(resid(probe.distance_target_var_1))
qqline(resid(probe.distance_target_var_1))

# TBD: refit with REML

# statistics 
anova(probe.distance_target_var_1, type="marginal", adjustSigma=T)
emmeans(probe.distance_target_var_1, pairwise ~ group | condition, adjust="bonferroni")
emmeans(probe.distance_target_var_1, pairwise ~ condition | group, adjust="bonferroni")



## -- path edit distance  -- ##


# ::: MEANING: Strong group, session and condition main effects and some (potentially instable, because barely significant) interaction effects. However planned contrasts do not show meaningful interactions. Explore further/make sure not anti-conservative ::: #

```

```{r stats_probe_rotation}

# ::: METHOD: several trials p. p. (session, condition) with metric (but possibly non-gaussian) outcome, therefore lmm model. Check if modelling of variance (heteroscedasticity) improves model significantly, i.e. use (n)lme instead of lmer/mixed. Disadvantages are that no non-gaussian distributions and potentially anti-conservative p-values (no Satterthwaite/Kenward-Roger df correction) ::: 


## -- rotation (normalized by path length)  -- ##
# **** sessions T1 & T2 **** # 
## 1) standard lme model without variance estimation 

probe.rot <- lme(log(rotation_turns_by_path_length) ~ group*session*condition,
                 random=list(id=pdDiag(~ condition + session)),
                 data=data, method="ML")

## 2) advanced lme model withvariance estimation

probe.rot_var <- update(probe.rot, weights=varIdent(form=~1 | group))
anova(probe.rot, probe.rot_var) 

probe.rot_var2 <- update(probe.rot, weights=varIdent(form=~1 | condition))

probe.rot_var3 <- update(probe.rot, weights=varComb(varIdent(form=~1 | condition),
                                                    varIdent(form=~1 | group)))

anova(probe.rot, probe.rot_var, probe.rot_var2, probe.rot_var3) 


# diagnostics
plot(probe.rot_var3, resid(., type="p") ~ fitted(.))
plot(probe.rot_var3, resid(., type="p") ~ fitted(.) | group)
plot(probe.rot_var3, group ~ resid(., type="p"))
qqnorm(resid(probe.rot_var2))
qqline(resid(probe.rot_var2))

# TBD: refit with REML

# statistics 
anova(probe.rot_var, type="marginal", adjustSigma=T)
emmeans(probe.rot_var, pairwise ~ group | session, adjust="bonferroni")
emmeans(probe.rot_var, pairwise ~ session | group, adjust="bonferroni")
emmeans(probe.rot_var, pairwise ~ group | condition, adjust="bonferroni")
emmeans(probe.rot_var, pairwise ~ condition | group, adjust="bonferroni")
emmeans(probe.rot_var, pairwise ~ session | condition, adjust="bonferroni")
emmeans(probe.rot_var, pairwise ~ condition | session, adjust="bonferroni")


# **** sessions T1 only **** # 
## 1) standard lme model without variance estimation 

probe.rot_1 <- lme(rotation_turns_by_path_length ~ group*condition,
                   random=list(id=pdDiag(~ condition)),
                   data=data_1, method="ML")

## 2) advanced lme model withvariance estimation

probe.rot_var_1 <- update(probe.rot_1, weights=varIdent(form=~1 | group))
anova(probe.rot_1, probe.rot_var_1) 

# diagnostics
plot(probe.rot_1, resid(., type="p") ~ fitted(.))
plot(probe.rot_1, resid(., type="p") ~ fitted(.) | group)
plot(probe.rot_1, group ~ resid(., type="p"))
qqnorm(resid(probe.rot_1))
qqline(resid(probe.rot_1))

# TBD: refit with REML

# statistics 
anova(probe.rot_1, type="marginal", adjustSigma=T)
emmeans(probe.rot_1, pairwise ~ group | condition, adjust="bonferroni")
emmeans(probe.rot_1, pairwise ~ condition | group, adjust="bonferroni")


# ::: MEANING: Strong interaction effects (mostly driven by session 2!). TBD! Check distribution (bimodal), check rotation raw values. Explore further/make sure not anti-conservative ::: #

```

```{r stats_probe_strategy}

table(data$search_strategy, data$group)

da <- data %>% filter(condition=="allo_ret")
table(da$search_strategy, da$group)
de <- data %>% filter(condition=="ego_ret")
table(de$search_strategy, de$group)


# option 1) fisher test: tests independence of rows and columns in a contingency table with fixed marginals.
fisher.test(table(data$search_strategy, data$group), simulate.p.value=T)

# option 2) discANOVA from WRS2: tests hypothesis that independent groups have identical multinomial distributions. 
discANOVA(search_strategy ~ group, data=data, nboot=500) 
discmcp(search_strategy ~ group, data=data, alpha=0.05, nboot=500)

discANOVA(search_strategy ~ group, data=data %>% filter(condition=="allo_ret"), nboot=500) 
discmcp(search_strategy ~ group, data=data %>% filter(condition=="allo_ret"), alpha=0.05, nboot=500)

discANOVA(search_strategy ~ group, data=data %>% filter(condition=="ego_ret"), nboot=500) 
discmcp(search_strategy ~ group, data=data %>% filter(condition=="ego_ret"), alpha=0.05, nboot=500)

```



```{r stats_probe}

### EXPLORATIV 

data_ego <- data %>% 
  filter(condition=="ego_ret") %>% 
  select(id, group, session, trial, block, condition, goal_i, correct_final_alley) %>% 
  mutate(goal_f=factor(goal_i))

probe_ego.acc <- mixed(correct_final_alley ~ group*session*goal_f +  
                         (session*goal_f||id), data=data_ego, expand_re=T,
                   family=binomial(link="logit"), method="LRT",
                   control=glmerControl(optimizer="bobyqa", optCtrl=list(maxfun=1e6)))

afex_plot(probe_ego.acc, "session", "group", "goal_f", id = "id",
          data_geom = ggbeeswarm::geom_quasirandom)

emmeans(probe_ego.acc, pairwise ~ group | session | goal_f, type="response", adjust="bonferroni")
emmeans(probe_ego.acc, pairwise ~ goal_f, type="response", adjust="bonferroni")
emmeans(probe_ego.acc, pairwise ~ group, type="response", adjust="bonferroni")
emmeans(probe_ego.acc, pairwise ~ session, type="response", adjust="bonferroni")


# data_allo <- data %>% 
#   filter(condition=="allo_ret") %>% 
#   select(id, group, session, trial, block, condition, goal_i, correct_final_alley) %>% 
#   mutate(goal_f=factor(goal_i))
# 
# probe_allo.acc <- mixed(correct_final_alley ~ group*session*goal_f +  
#                          (session+goal_f||id), data=data_allo, expand_re=T,
#                    family=binomial(link="logit"), method="LRT",
#                    control=glmerControl(optimizer="bobyqa", optCtrl=list(maxfun=1e6)))
# 
# afex_plot(probe_allo.acc, "session", "group", "goal_f", id = "id",
#           data_geom = ggbeeswarm::geom_quasirandom)
# 
# emmeans(probe_allo.acc, pairwise ~ group | session | goal_f, type="response", adjust="bonferroni")
# emmeans(probe_allo.acc, pairwise ~ goal_f, type="response", adjust="bonferroni")
# emmeans(probe_allo.acc, pairwise ~ group, type="response", adjust="bonferroni")
# emmeans(probe_allo.acc, pairwise ~ session, type="response", adjust="bonferroni")

t1 <- data_l %>% 
  select(id, group, session, trial, goal_i, correct_final_alley, time, path_distance) %>% 
  mutate(goal_f=factor(goal_i)) %>% 
  group_by(id, group, session, goal_f) %>% 
  summarize(correct_final_alley=mean(correct_final_alley, na.rm=T),
            time=mean(time, na.rm=T),
            path=mean(path_distance, na.rm=T))

ggplot(t1, aes(x=goal_f, y=time)) +
  geom_boxplot() +
  facet_wrap(~ group)

ggplot(t1, aes(x=goal_f, y=path)) +
  geom_boxplot() +
  facet_wrap(~ group)


t2 <- data %>% 
  select(id, group, session, condition, trial, goal_i, correct_final_alley, final_distance, time, path_distance) %>% 
  mutate(goal_f=factor(goal_i)) %>% 
  filter(session==1) %>% 
  group_by(id, group, condition, goal_f) %>% 
  summarize(correct_final_alley=mean(correct_final_alley, na.rm=T),
            final_distance=mean(final_distance, na.rm=T),
            time=mean(time, na.rm=T),
            path=mean(path_distance, na.rm=T))

ggplot(t2, aes(x=goal_f, y=final_distance)) +
  geom_boxplot() +
  facet_grid(condition ~ group)

ggplot(t2, aes(x=goal_f, y=time)) +
  geom_boxplot() +
  facet_grid(condition ~ group)

ggplot(t2, aes(x=goal_f, y=path)) +
  geom_boxplot() +
  facet_grid(condition ~ group)

ggplot(t2, aes(x=goal_f, y=final_distance)) +
  geom_boxplot() +
  facet_wrap(~ condition)

ggplot(t2, aes(x=goal_f, y=time)) +
  geom_boxplot() +
  facet_wrap(~ condition)

ggplot(t2, aes(x=goal_f, y=path)) +
  geom_boxplot() +
  facet_wrap(~ condition)

```


### Post-navigation memory test
#### Identifying the maze layout 

```{r stats_layout}

data <- pt_data %>% 
  filter(condition=="layout") %>% 
  drop_na(score)

# option 1) fisher test: tests independence of rows and columns in a contingency table with fixed marginals.
fisher.test(table(data$score, data$group))
pairwise_fisher_test(table(data$score, data$group), p.adjust.method="bonferroni")

# option 2) discANOVA from WRS2: tests hypothesis that independent groups have identical multinomial distributions. 
discANOVA(score ~ group, data=data, nboot=500)
discmcp(score ~ group, data=data, alpha=0.05, nboot=500) 

# ::: MEANING: significant differences between age groups in performance ::: #

```

#### Identifying the landmarks 

```{r stats_landmark}
data <- pt_data %>% 
  filter(condition=="landmarks") %>% 
  drop_na(score)

# option 1) standard ANOVA
aov.lm <- aov_car(score ~ group + Error(id), data=data)
qqPlot(data$score) # non-normality
data %>% shapiro_test(score) 
plot(predict(aov.lm), residuals(aov.lm), main="Residuals vs. Predicted") # homoscedasticity ok
data %>% levene_test(score ~ group) 
summary(aov.lm)
emmeans(aov.lm, pairwise ~ group, adjust="bonferroni")

# option 2) robust ANOVA (WSR2)
t1way(score ~ group, data=data, tr=0.2, nboot=1000)
lincon(score ~ group, data=data, tr=0.2, nboot=1000, method="bonferroni")

# ::: MEANING: no reliable, significant differences between age groups in performance ::: #

```

#### Identifying the relationships between landmarks and goals 

```{r stats_gmda}

data <- pt_data %>% 
  filter(condition=="position") %>% 
  drop_na(score)

# option 1) standard ANOVA
aov.gmda <- aov_car(score ~ group + Error(id), data=data)
qqPlot(data$score) # non-normality
data %>% shapiro_test(score) 
plot(predict(aov.gmda), residuals(aov.gmda), main="Residuals vs. Predicted") # heteroscedasticity
data %>% levene_test(score ~ group) 
summary(aov.gmda)
emmeans(aov.gmda, pairwise ~ group, adjust="bonferroni")

# option 2) robust ANOVA (WSR2)
t1way(score ~ group, data=data, tr=0.2, nboot=1000)
lincon(score ~ group, data=data, tr=0.2, nboot=1000, method="bonferroni")

# ::: MEANING: significant differences between children and adults in performance ::: #

```

```{r stats_gmda_explore}

# file_name <- "../WP10_data/WP10_results/wp10_GMDA_data_220505.Rdata"
# load(file_name)
# rm(file_name)

# # individual scores
# CanOrg <- data_gmda %>% filter(gmda_measure=="SQRT(CanOrg)")
# CanAcc <- data_gmda %>% filter(gmda_measure=="CanAcc")
# DistAcc <- data_gmda %>% filter(gmda_measure=="DistAcc")
# AngleAcc <- data_gmda %>% filter(gmda_measure=="AngleAcc")

# boxplot <- function(d){
#   ggplot(data=d, aes(x=group, y=score, fill=group)) +
#     geom_boxplot(outlier.shape=NA) +
#     geom_point()
# }

# boxplot(CanOrg)
# lincon(score ~ group, data=CanOrg, tr=0.2, nboot=1000, method="bonferroni")

# boxplot(CanAcc)
# lincon(score ~ group, data=CanAcc, tr=0.2, nboot=1000, method="bonferroni")

# boxplot(DistAcc)
# lincon(score ~ group, data=DistAcc, tr=0.2, nboot=1000, method="bonferroni")

# boxplot(AngleAcc)
# lincon(score ~ group, data=AngleAcc, tr=0.2, nboot=1000, method="bonferroni")

# # composite score
# GMDA <- data_gmda %>% filter(gmda_measure %in% c("SQRT(CanOrg)", "CanAcc", "DistAcc", "AngleAcc")) %>%
#   group_by(id, group) %>% summarise(score=mean(score))

# boxplot(GMDA)
# lincon(score ~ group, data=GMDA, tr=0.2, nboot=1000, method="bonferroni")

# rm(data_gmda, GMDA, CanOrg, CanAcc, DistAcc, AngleAcc, boxplot)
   
```

```{r end}

rm(list=ls(pattern="x"))

```